<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>rxjs学习 | Ace&#39;pages</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="https://segmentfault.com/a/1190000012252368 RxJS: 简单入门 rxjs 14**** Introduction to RxJS1. 前言1.1 什么是RxJS？RxJS是ReactiveX编程理念的JavaScript版本。ReactiveX来自微软，它是一种针对异步数据流的编程。简单来说，它将一切数据，包括HTTP请求，DOM事件或者普通数据等包装">
<meta name="keywords" content="rxjs,angular">
<meta property="og:type" content="article">
<meta property="og:title" content="rxjs学习">
<meta property="og:url" content="http://hujao.com/2018/07/23/rxjs/index.html">
<meta property="og:site_name" content="Ace&#39;pages">
<meta property="og:description" content="https://segmentfault.com/a/1190000012252368 RxJS: 简单入门 rxjs 14**** Introduction to RxJS1. 前言1.1 什么是RxJS？RxJS是ReactiveX编程理念的JavaScript版本。ReactiveX来自微软，它是一种针对异步数据流的编程。简单来说，它将一切数据，包括HTTP请求，DOM事件或者普通数据等包装">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://segmentfault.com/img/bVXtzg?w=754&h=378">
<meta property="og:updated_time" content="2018-07-27T17:41:22.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="rxjs学习">
<meta name="twitter:description" content="https://segmentfault.com/a/1190000012252368 RxJS: 简单入门 rxjs 14**** Introduction to RxJS1. 前言1.1 什么是RxJS？RxJS是ReactiveX编程理念的JavaScript版本。ReactiveX来自微软，它是一种针对异步数据流的编程。简单来说，它将一切数据，包括HTTP请求，DOM事件或者普通数据等包装">
<meta name="twitter:image" content="https://segmentfault.com/img/bVXtzg?w=754&h=378">
  
    <link rel="alternate" href="/atom.xml" title="Ace&#39;pages" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-rxjs" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/categories/docker">Docker</a>
    
      <a class="main-nav-link" href="/categories/springboot">SpringBoot</a>
    
      <a class="main-nav-link" href="/categories/elasticsearch">ElasticSearch</a>
    
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      rxjs学习
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <p><a href="https://segmentfault.com/a/1190000012252368" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012252368</a></p>
<h1 id="RxJS-简单入门"><a href="#RxJS-简单入门" class="headerlink" title="RxJS: 简单入门"></a><a href="https://segmentfault.com/a/1190000012252368" target="_blank" rel="noopener">RxJS: 简单入门</a></h1><p> <a href="https://segmentfault.com/t/rxjs/blogs" target="_blank" rel="noopener">rxjs</a></p>
<p><em>14</em><a href="">**</a><strong><strong>**</strong></strong></p>
<h1 id="Introduction-to-RxJS"><a href="#Introduction-to-RxJS" class="headerlink" title="Introduction to RxJS"></a>Introduction to <code>RxJS</code></h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><h3 id="1-1-什么是RxJS？"><a href="#1-1-什么是RxJS？" class="headerlink" title="1.1 什么是RxJS？"></a>1.1 什么是<code>RxJS</code>？</h3><p><code>RxJS</code>是<code>ReactiveX</code>编程理念的<code>JavaScript</code>版本。<code>ReactiveX</code>来自微软，它是一种针对异步数据流的编程。简单来说，它将一切数据，包括HTTP请求，DOM事件或者普通数据等包装成流的形式，然后用强大丰富的操作符对流进行处理，使你能以同步编程的方式处理异步数据，并组合不同的操作符来轻松优雅的实现你所需要的功能。</p>
<h3 id="1-2-RxJS可用于生产吗？"><a href="#1-2-RxJS可用于生产吗？" class="headerlink" title="1.2 RxJS可用于生产吗？"></a>1.2 <code>RxJS</code>可用于生产吗？</h3><p><code>ReactiveX</code>由微软于2012年开源，目前各语言库由<code>ReactiveX</code>组织维护。<code>RxJS</code>在<code>GitHub</code>上已有<code>8782</code>个star，目前最新版本为<code>5.5.2</code>，并持续开发维护中，其中官方测试用例共计<code>2699</code>个。</p>
<p><img src="https://segmentfault.com/img/bVXtzg?w=754&amp;h=378" alt="谁在使用Rx"></p>
<h3 id="1-3-RxJS对项目代码的影响？"><a href="#1-3-RxJS对项目代码的影响？" class="headerlink" title="1.3 RxJS对项目代码的影响？"></a>1.3 <code>RxJS</code>对项目代码的影响？</h3><p><code>RxJS</code>中的流以<code>Observable</code>对象呈现，获取数据需要订阅<code>Observable</code>，形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const ob = http$.getSomeList(); //getSomeList()返回某个由`Observable`包装后的http请求</span><br><span class="line">ob.subscribe((data) =&gt; console.log(data));</span><br><span class="line">//在变量末尾加$表示Observable类型的对象。</span><br></pre></td></tr></table></figure>
<p>以上与<code>Promise</code>类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const promise = http.getSomeList(); // 返回由`Promise`包装的http请求</span><br><span class="line">promise.then((data) =&gt; console.log(data));</span><br></pre></td></tr></table></figure>
<p>实际上<code>Observable</code>可以认为是加强版的<code>Promise</code>，它们之间是可以通过<code>RxJS</code>的<code>API</code>互相转换的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const ob = Observable.fromPromise(somePromise); // Promise转为Observable</span><br><span class="line">const promise = someObservable.toPromise(); // Observable转为Promise</span><br></pre></td></tr></table></figure>
<p>因此可以在<code>Promise</code>方案的项目中安全使用<code>RxJS</code>，并能够随时升级到完整的<code>RxJS</code>方案。</p>
<h3 id="1-4-RxJS会增加多少体积？"><a href="#1-4-RxJS会增加多少体积？" class="headerlink" title="1.4 RxJS会增加多少体积？"></a>1.4 <code>RxJS</code>会增加多少体积？</h3><p><code>RxJS</code>整个库压缩后约为<code>140KB</code>，由于其模块化可扩展的设计，因此仅需导入所用到的类与操作符即可。经测试，在导入<code>RxJS</code>常用类与操作符后，<code>build</code>体积增加了约<code>27KB</code>。</p>
<h2 id="2-RxJS快速入门"><a href="#2-RxJS快速入门" class="headerlink" title="2. RxJS快速入门"></a>2. <code>RxJS</code>快速入门</h2><h3 id="2-1-初级核心概念"><a href="#2-1-初级核心概念" class="headerlink" title="2.1 初级核心概念"></a>2.1 初级核心概念</h3><ul>
<li><code>Observable</code></li>
<li><code>Observer</code></li>
<li><code>Operator</code></li>
</ul>
<p><code>Observable</code>被称为可观察序列，简单来说数据就在<code>Observable</code>中流动，你可以使用各种<code>operator</code>对流进行处理，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const ob = Observable.interval(1000);</span><br><span class="line">ob.take(3).map(n =&gt; n * 2).filter(n =&gt; n &gt; 2);</span><br></pre></td></tr></table></figure>
<p>第一步代码我们通过类方法<code>interval</code>创建了一个<code>Observable</code>序列，<code>ob</code>作为源会每隔<code>1000ms</code>发射一个递增的数据，即<code>0 -&gt; 1 -&gt; 2</code>。第二步我们使用操作符对流进行处理，<code>take(3)</code>表示只取源发射的前<code>3</code>个数据，取完第三个后关闭源的发射；<code>map</code>表示将流中的数据进行映射处理，这里我们将数据翻倍；<code>filter</code>表示过滤掉出符合条件的数据，根据上一步<code>map</code>的结果，只有第二和第三个数据会留下来。</p>
<p>上面我们已经使用同步编程创建好了一个流的处理过程，但此时<code>ob</code>作为源并不会立刻发射数据，如果我们在<code>map</code>中打印<code>n</code>是不会得到任何输出的，因为<code>ob</code>作为<code>Observable</code>序列必须被“订阅”才能够触发上述过程，也就是<code>subscribe</code>（发布/订阅模式）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const ob = Observable.interval(1000);</span><br><span class="line">ob.take(3).map(n =&gt; n * 2).filter(n =&gt; n &gt; 0).subscribe(n =&gt; console.log(n));</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 //第2秒</span><br><span class="line">4 //第3秒</span><br></pre></td></tr></table></figure>
<p>上面代码中我们给<code>subscribe</code>传入了一个函数，这其实是一种简写，<code>subscribe</code>完整的函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ob.subscribe(&#123;</span><br><span class="line">    next: d =&gt; console.log(d),</span><br><span class="line">    error: err =&gt; console.error(err),</span><br><span class="line">    complete: () =&gt; console.log(&apos;end of the stream&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>直接给<code>subscribe</code>传入一个函数会被当做是<code>next</code>函数。这个完整的包含3个函数的对象被称为<code>observer</code>（观察者），表示的是对序列结果的处理方式。<code>next</code>表示数据正常流动，没有出现异常；<code>error</code>表示流中出错，可能是运行出错，<code>http</code>报错等等；<code>complete</code>表示流结束，不再发射新的数据。在一个流的生命周期中，<code>error</code>和<code>complete</code>只会触发其中一个，可以有多个<code>next</code>（表示多次发射数据），直到<code>complete</code>或者<code>error</code>。</p>
<p><code>observer.next</code>可以认为是<code>Promise</code>中<code>then</code>的第一个参数，<code>observer.error</code>对应第二个参数或者<code>Promise</code>的<code>catch</code>。</p>
<p><code>RxJS</code>同样提供了<code>catch</code>操作符，<code>err</code>流入<code>catch</code>后，<code>catch</code>必须返回一个新的<code>Observable</code>。被<code>catch</code>后的错误流将不会进入<code>observer</code>的<code>error</code>函数，除非其返回的新<code>observable</code>出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.of(1).map(n =&gt; n.undefinedMethod()).catch(err =&gt; &#123;</span><br><span class="line">    // 此处处理catch之前发生的错误</span><br><span class="line">    return Observable.of(0); // 返回一个新的序列，该序列成为新的流。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-2-创建可观察序列"><a href="#2-2-创建可观察序列" class="headerlink" title="2.2 创建可观察序列"></a>2.2 创建可观察序列</h3><p>创建一个序列有很多种方式，我们仅列举常用的几种：</p>
<h4 id="Observable-of-args"><a href="#Observable-of-args" class="headerlink" title="Observable.of(...args)"></a><code>Observable.of(...args)</code></h4><p><code>Observable.of()</code>可以将普通JavaScript数据转为可观察序列，<a href="http://xgrommx.github.io/rx-book/content/observable/observable_methods/of.html" target="_blank" rel="noopener">点我测试</a>。</p>
<h4 id="Observable-fromPromise-promise"><a href="#Observable-fromPromise-promise" class="headerlink" title="Observable.fromPromise(promise)"></a><code>Observable.fromPromise(promise)</code></h4><p>将<code>Promise</code>转化为<code>Observable</code>，<a href="http://xgrommx.github.io/rx-book/content/observable/observable_methods/frompromise.html" target="_blank" rel="noopener">点我测试</a>。</p>
<h4 id="Observable-fromEvent-elment-eventName"><a href="#Observable-fromEvent-elment-eventName" class="headerlink" title="Observable.fromEvent(elment, eventName)"></a><code>Observable.fromEvent(elment, eventName)</code></h4><p>从<code>DOM</code>事件创建序列，例如<code>Observable.fromEvent($input, &#39;click&#39;)</code>，<a href="http://xgrommx.github.io/rx-book/content/observable/observable_methods/fromevent.html" target="_blank" rel="noopener">点我测试</a>。</p>
<h4 id="Observable-ajax-url-AjaxRequest"><a href="#Observable-ajax-url-AjaxRequest" class="headerlink" title="Observable.ajax(url | AjaxRequest)"></a><code>Observable.ajax(url | AjaxRequest)</code></h4><p>发送<code>http</code>请求，<code>AjaxRequest</code>参考<a href="http://cn.rx.js.org/class/es6/observable/dom/MiscJSDoc.js~AjaxRequestDoc.html" target="_blank" rel="noopener">这里</a></p>
<h4 id="Observable-create-subscribe"><a href="#Observable-create-subscribe" class="headerlink" title="Observable.create(subscribe)"></a><code>Observable.create(subscribe)</code></h4><p>这个属于万能的创建方法，很少会用到，在你用这个方法之前先想想能不能用<code>RxJS</code>上的类方法来创建你所需要的序列，<a href="http://xgrommx.github.io/rx-book/content/observable/observable_methods/create.html" target="_blank" rel="noopener">点我测试</a>。</p>
<h3 id="2-3-合并序列"><a href="#2-3-合并序列" class="headerlink" title="2.3 合并序列"></a>2.3 合并序列</h3><p>合并序列也属于创建序列的一种，例如有这样的需求：进入某个页面后拿到了一个列表，然后需要对列表每一项发出一个<code>http</code>请求来获取对应的详细信息，这里我们把每个<code>http</code>请求作为一个序列，然后我们希望合并它们。<br>合并有很多种方式，例如N个请求按顺序串行发出（前一个结束再发下一个）；N个请求同时发出并且要求全部到达后合并为数组，触发一次回调；N个请求同时发出，对于每一个到达就触发一次回调。<br>如果不用<code>RxJS</code>，我们会比较难处理这么多情形，不仅实现麻烦，维护更麻烦，下面是使用<code>RxJS</code>对上述需求的解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ob1 = Observable.ajax(&apos;api/detail/1&apos;);</span><br><span class="line">const ob2 = Observable.ajax(&apos;api/detail/2&apos;);</span><br><span class="line">...</span><br><span class="line">const obs = [ob1, ob2...];</span><br><span class="line">// 分别创建对应的HTTP请求。</span><br></pre></td></tr></table></figure>
<ol>
<li>N个请求按顺序串行发出（前一个结束再发下一个）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.concat(...obs).subscribe(detail =&gt; console.log(&apos;每个请求都触发回调&apos;));</span><br></pre></td></tr></table></figure>
<ol>
<li>N个请求同时并行发出，对于每一个到达就触发一次回调</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.merge(...obs).subscribe(detail =&gt; console.log(&apos;每个请求都触发回调&apos;));</span><br></pre></td></tr></table></figure>
<ol>
<li>N个请求同时发出并且要求全部到达后合并为数组，触发一次回调</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.forkJoin(...obs).subscribe(detailArray =&gt; console.log(&apos;触发一次回调&apos;));</span><br></pre></td></tr></table></figure>
<h2 id="3-使用RxJS实现搜索功能"><a href="#3-使用RxJS实现搜索功能" class="headerlink" title="3. 使用RxJS实现搜索功能"></a>3. 使用<code>RxJS</code>实现搜索功能</h2><p>搜索是前端开发中很常见的功能，一般是监听<code>&lt;input /&gt;</code>的<code>keyup</code>事件，然后将内容发送到后台，并展示后台返回的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;text&quot;&gt;&lt;/input&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var text = document.querySelector(&apos;#text&apos;);</span><br><span class="line">    text.addEventListener(&apos;keyup&apos;, (e) =&gt;&#123;</span><br><span class="line">        var searchText = e.target.value;</span><br><span class="line">        // 发送输入内容到后台</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: `/search/$&#123;searchText&#125;`,</span><br><span class="line">            success: data =&gt; &#123;</span><br><span class="line">              // 拿到后台返回数据，并展示搜索结果</span><br><span class="line">              render(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码实现我们要的功能，但存在两个较大的问题：</p>
<ul>
<li><strong>多余的请求</strong></li>
</ul>
<p>当想搜索“爱迪生”时，输入框可能会存在三种情况，“爱”、“爱迪”、“爱迪生”。而这三种情况将会发起 3 次请求，存在 2 次多余的请求。</p>
<ul>
<li><strong>已无用的请求仍然执行</strong></li>
</ul>
<p>一开始搜了“爱迪生”，然后马上改搜索“达尔文”。结果后台返回了“爱迪生”的搜索结果，执行渲染逻辑后结果框展示了“爱迪生”的结果，而不是当前正在搜索的“达尔文”，这是不正确的。</p>
<p><strong>减少多余请求数</strong>，可以用 setTimeout 函数节流的方式来处理，核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;text&quot;&gt;&lt;/input&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var text = document.querySelector(&apos;#text&apos;),</span><br><span class="line">        timer = null;</span><br><span class="line">    text.addEventListener(&apos;keyup&apos;, (e) =&gt;&#123;</span><br><span class="line">        // 在 250 毫秒内进行其他输入，则清除上一个定时器</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        // 定时器，在 250 毫秒后触发</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&apos;发起请求..&apos;);</span><br><span class="line">        &#125;,250)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>已无用的请求仍然执行</strong> 的解决方式，可以在发起请求前声明一个当前搜索的状态变量，后台将搜索的内容及结果一起返回，前端判断返回数据与当前搜索是否一致，一致才走到渲染逻辑。最终代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;text&quot;&gt;&lt;/input&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var text = document.querySelector(&apos;#text&apos;),</span><br><span class="line">        timer = null,</span><br><span class="line">        currentSearch = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    text.addEventListener(&apos;keyup&apos;, (e) =&gt;&#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">            // 声明一个当前所搜的状态变量</span><br><span class="line">            currentSearch ＝ &apos;书&apos;; </span><br><span class="line"></span><br><span class="line">            var searchText = e.target.value;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url: `/search/$&#123;searchText&#125;`,</span><br><span class="line">                success: data =&gt; &#123;</span><br><span class="line">                    // 判断后台返回的标志与我们存的当前搜索变量是否一致</span><br><span class="line">                    if (data.search === currentSearch) &#123;</span><br><span class="line">                        // 渲染展示</span><br><span class="line">                        render(data);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // ..</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,250)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码基本满足需求，但代码开始显得乱糟糟。我们来使用<code>RxJS</code>实现上面代码功能，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var text = document.querySelector(&apos;#text&apos;);</span><br><span class="line">var inputStream = Rx.Observable.fromEvent(text, &apos;keyup&apos;)</span><br><span class="line">                    .debounceTime(250)</span><br><span class="line">                    .pluck(&apos;target&apos;, &apos;value&apos;)</span><br><span class="line">                    .switchMap(url =&gt; Http.get(url))</span><br><span class="line">                    .subscribe(data =&gt; render(data));</span><br></pre></td></tr></table></figure>
<p><code>RxJS</code>能简化你的代码，它将与流有关的内部状态封装在流中，而不需要在流外定义各种变量来以一种上帝视角控制流程。<code>Rx</code>的编程方式使你的业务逻辑流程清晰，易维护，并显著减少出bug的概率。</p>
<h3 id="个人总结的常用操作符："><a href="#个人总结的常用操作符：" class="headerlink" title="个人总结的常用操作符："></a>个人总结的常用操作符：</h3><p>类操作符（通常为合并序列或从已有数据创建序列）<br><strong>合并</strong> <code>forkJoin</code>, <code>merge</code>, <code>concat</code><br><strong>创建</strong> <code>of</code>, <code>from</code>, <code>fromPromise</code>, <code>fromEvent</code>, <code>ajax</code>, <code>throw</code><br>实例操作符（对流中的数据进行处理或者控制流程）<br><code>map</code>, <code>filter</code>,<code>switchMap</code>, <code>toPromise</code>, <code>catch</code>, <code>take</code>, <code>takeUntil</code>, <code>timeout</code>, <code>debounceTime</code>, <code>distinctUntilChanged</code>, <code>pluck</code>。<br>对于这些操作符的使用不再详细描述，请参阅网上资料。</p>
<p>中文官网 <a href="http://cn.rx.js.org/" target="_blank" rel="noopener">http://cn.rx.js.org/</a><br>附上个人翻译的两篇文章</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000011052037" target="_blank" rel="noopener">RxJS：冷热模式的比较</a></li>
<li><a href="https://segmentfault.com/a/1190000011070872" target="_blank" rel="noopener">RxJS: map, flatMap和flatMapLatest的区别</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2018/07/23/rxjs/" class="article-date">
  <time datetime="2018-07-23T12:00:14.000Z" itemprop="datePublished">2018-07-23</time>
</a>

        </li>
        
        
          <li>
            <span class="label">Tag:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/angular/">angular</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rxjs/">rxjs</a></li></ul>


          </li>
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2018/07/24/sqlserver-log/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          日志过大导致sqlserver数据库无法启动
        
      </div>
    </a>
  
  
    <a href="/2018/07/23/PersistenceContext/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">EntityManager相关</div>
    </a>
  
</nav>


  
</article>




      </div>
      
    <footer id="footer" class="post-footer footer">
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>闲步山雨后,静待晚林风 Post</p>


      </div>
    </footer>

      

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
