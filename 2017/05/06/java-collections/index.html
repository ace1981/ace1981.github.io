<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>java集合类学习 | Ace&#39;pages</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. Java集合类基本概念
在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据(在编译时无法确定具体的数量)，java的集合类就是一个很好的设计方案了。
集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。">
<meta property="og:type" content="article">
<meta property="og:title" content="java集合类学习">
<meta property="og:url" content="http://hujao.com/2017/05/06/java-collections/index.html">
<meta property="og:site_name" content="Ace'pages">
<meta property="og:description" content="1. Java集合类基本概念
在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据(在编译时无法确定具体的数量)，java的集合类就是一个很好的设计方案了。
集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。">
<meta property="og:image" content="http://images.cnitblog.com/i/532548/201404/262238192165666.jpg">
<meta property="og:updated_time" content="2017-12-21T05:52:03.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java集合类学习">
<meta name="twitter:description" content="1. Java集合类基本概念
在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据(在编译时无法确定具体的数量)，java的集合类就是一个很好的设计方案了。
集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。">
<meta name="twitter:image" content="http://images.cnitblog.com/i/532548/201404/262238192165666.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Ace&#39;pages" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-java-collections" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/categories">Categories</a>
    
      <a class="main-nav-link" href="/tags">Tags</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java集合类学习
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <p><strong>1. Java集合类基本概念</strong></p>
<p>在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据(在编译时无法确定具体的数量)，java的集合类就是一个很好的设计方案了。</p>
<p>集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所以的集合类都位于java.util包下，后来为了处理多线程环境下的并发安全问题，java5还在java.util.concurrent包下提供了一些多线程支持的集合类。</p>
<p>在学习Java中的集合类的API、编程原理的时候，我们一定要明白，”集合”是一个很古老的数学概念，它远远早于Java的出现。从数学概念的角度来理解集合能帮助我们更好的理解编程中什么时候该使用什么类型的集合类。</p>
<p>Java容器类类库的用途是”保存对象”，并将其划分为两个不同的概念：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1) Collection</div><div class="line">一组&quot;对立&quot;的元素，通常这些元素都服从某种规则</div><div class="line"> 　　1.1) List必须保持元素特定的顺序</div><div class="line"> 　　1.2) Set不能有重复元素</div><div class="line"> 　　1.3) Queue保持一个队列(先进先出)的顺序</div><div class="line">2) Map</div><div class="line">一组成对的&quot;键值对&quot;对象</div></pre></td></tr></table></figure>
<p>Collection和Map的区别在于容器中每个位置保存的元素个数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1) Collection 每个位置只能保存一个元素(对象)</div><div class="line">2) Map保存的是&quot;键值对&quot;，就像一个小型数据库。我们可以通过&quot;键&quot;找到该键对应的&quot;值&quot;</div></pre></td></tr></table></figure>
<p><strong>2. Java集合类架构层次关系</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">1. Interface Iterable</div><div class="line">迭代器接口，这是Collection类的父接口。实现这个Iterable接口的对象允许使用foreach进行遍历，也就是说，所有的Collection集合对象都具有&quot;foreach可遍历性&quot;。这个Iterable接口只</div><div class="line">有一个方法: iterator()。它返回一个代表当前集合对象的泛型&lt;T&gt;迭代器，用于之后的遍历操作</div><div class="line">1.1 Collection</div><div class="line">Collection是最基本的集合接口，一个Collection代表一组Object的集合，这些Object被称作Collection的元素。Collection是一个接口，用以提供规范定义，不能被实例化使用</div><div class="line">    1) Set</div><div class="line">    Set集合类似于一个罐子，&quot;丢进&quot;Set集合里的多个对象之间没有明显的顺序。Set继承自Collection接口，不能包含有重复元素(记住，这是整个Set类层次的共有属性)。</div><div class="line">    Set判断两个对象相同不是使用&quot;==&quot;运算符，而是根据equals方法。也就是说，我们在加入一个新元素的时候，如果这个新元素对象和Set中已有对象进行注意equals比较都返回false，　　</div><div class="line"> 　 则Set就会接受这个新元素对象，否则拒绝。</div><div class="line">    因为Set的这个制约，在使用Set集合的时候，应该注意两点：1) 为Set集合里的元素的实现类实现一个有效的equals(Object)方法、2) 对Set的构造函数，传入的Collection参数不能包</div><div class="line">　　含重复的元素</div><div class="line">        1.1) HashSet</div><div class="line">        HashSet是Set接口的典型实现，HashSet使用HASH算法来存储集合中的元素，因此具有良好的存取和查找性能。当向HashSet集合中存入一个元素时，HashSet会调用该对象的</div><div class="line">　　　　 hashCode()方法来得到该对象的hashCode值，然后根据该HashCode值决定该对象在HashSet中的存储位置。</div><div class="line">        值得主要的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等</div><div class="line">            1.1.1) LinkedHashSet</div><div class="line">            LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但和HashSet不同的是，它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。</div><div class="line">　　　　　　　当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。</div><div class="line">            LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但在迭代访问Set里的全部元素时(遍历)将有很好的性能(链表很适合进行遍历)</div><div class="line">        1.2) SortedSet    </div><div class="line">        此接口主要用于排序操作，即实现此接口的子类都属于排序的子类</div><div class="line">            1.2.1) TreeSet</div><div class="line">            TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态</div><div class="line">        1.3) EnumSet</div><div class="line">        EnumSet是一个专门为枚举类设计的集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式、或隐式地指定。EnumSet的集合元素也是有序的，</div><div class="line">　　　　 它们以枚举值在Enum类内的定义顺序来决定集合元素的顺序</div><div class="line">    2) List</div><div class="line">    List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许加入重复元素，因为它可以通过索引来访问指定位置的集合元素。List集合默认按元素</div><div class="line">　　 的添加顺序设置元素的索引</div><div class="line">        2.1) ArrayList</div><div class="line">        ArrayList是基于数组实现的List类，它封装了一个动态的增长的、允许再分配的Object[]数组。</div><div class="line">        2.2) Vector</div><div class="line">        Vector和ArrayList在用法上几乎完全相同，但由于Vector是一个古老的集合，所以Vector提供了一些方法名很长的方法，但随着JDK1.2以后，java提供了系统的集合框架，就将</div><div class="line">　　　　 Vector改为实现List接口，统一归入集合框架体系中</div><div class="line">            2.2.1) Stack</div><div class="line">            Stack是Vector提供的一个子类，用于模拟&quot;栈&quot;这种数据结构(LIFO后进先出)</div><div class="line">        2.3) LinkedList</div><div class="line">        implements List&lt;E&gt;, Deque&lt;E&gt;。实现List接口，能对它进行队列操作，即可以根据索引来随机访问集合中的元素。同时它还实现Deque接口，即能将LinkedList当作双端队列</div><div class="line">　　　　 使用。自然也可以被当作&quot;栈来使用&quot;</div><div class="line">    3) Queue</div><div class="line">    Queue用于模拟&quot;队列&quot;这种数据结构(先进先出 FIFO)。队列的头部保存着队列中存放时间最长的元素，队列的尾部保存着队列中存放时间最短的元素。新元素插入(offer)到队列的尾部，</div><div class="line">　　 访问元素(poll)操作会返回队列头部的元素，队列不允许随机访问队列中的元素。结合生活中常见的排队就会很好理解这个概念</div><div class="line">        3.1) PriorityQueue</div><div class="line">        PriorityQueue并不是一个比较标准的队列实现，PriorityQueue保存队列元素的顺序并不是按照加入队列的顺序，而是按照队列元素的大小进行重新排序，这点从它的类名也可以</div><div class="line">　　　　 看出来</div><div class="line">        3.2) Deque</div><div class="line">        Deque接口代表一个&quot;双端队列&quot;，双端队列可以同时从两端来添加、删除元素，因此Deque的实现类既可以当成队列使用、也可以当成栈使用</div><div class="line">            3.2.1) ArrayDeque</div><div class="line">            是一个基于数组的双端队列，和ArrayList类似，它们的底层都采用一个动态的、可重分配的Object[]数组来存储集合元素，当集合元素超出该数组的容量时，系统会在底层重</div><div class="line">　　　　　　　新分配一个Object[]数组来存储集合元素</div><div class="line">            3.2.2) LinkedList</div><div class="line">1.2 Map</div><div class="line">Map用于保存具有&quot;映射关系&quot;的数据，因此Map集合里保存着两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value。key和value都可以是任何引用类型的数据。Map的key不允</div><div class="line">许重复，即同一个Map对象的任何两个key通过equals方法比较结果总是返回false。</div><div class="line">关于Map，我们要从代码复用的角度去理解，java是先实现了Map，然后通过包装了一个所有value都为null的Map就实现了Set集合</div><div class="line">Map的这些实现类和子接口中key集的存储形式和Set集合完全相同(即key不能重复)</div><div class="line">Map的这些实现类和子接口中value集的存储形式和List非常类似(即value可以重复、根据索引来查找)</div><div class="line">    1) HashMap</div><div class="line">    和HashSet集合不能保证元素的顺序一样，HashMap也不能保证key-value对的顺序。并且类似于HashSet判断两个key是否相等的标准也是: 两个key通过equals()方法比较返回true、</div><div class="line">　　 同时两个key的hashCode值也必须相等</div><div class="line">        1.1) LinkedHashMap</div><div class="line">        LinkedHashMap也使用双向链表来维护key-value对的次序，该链表负责维护Map的迭代顺序，与key-value对的插入顺序一致(注意和TreeMap对所有的key-value进行排序进行区</div><div class="line">分)</div><div class="line">    2) Hashtable</div><div class="line">    是一个古老的Map实现类</div><div class="line">        2.1) Properties </div><div class="line">        Properties对象在处理属性文件时特别方便(windows平台上的.ini文件)，Properties类可以把Map对象和属性文件关联起来，从而可以把Map对象中的key-value对写入到属性文</div><div class="line">　　　　　件中，也可以把属性文件中的&quot;属性名-属性值&quot;加载到Map对象中</div><div class="line">    3) SortedMap</div><div class="line">    正如Set接口派生出SortedSet子接口，SortedSet接口有一个TreeSet实现类一样，Map接口也派生出一个SortedMap子接口，SortedMap接口也有一个TreeMap实现类</div><div class="line">        3.1) TreeMap</div><div class="line">        TreeMap就是一个红黑树数据结构，每个key-value对即作为红黑树的一个节点。TreeMap存储key-value对(节点)时，需要根据key对节点进行排序。TreeMap可以保证所有的</div><div class="line">　　　　 key-value对处于有序状态。同样，TreeMap也有两种排序方式: 自然排序、定制排序</div><div class="line">    4) WeakHashMap</div><div class="line">    WeakHashMap与HashMap的用法基本相似。区别在于，HashMap的key保留了对实际对象的&quot;强引用&quot;，这意味着只要该HashMap对象不被销毁，该HashMap所引用的对象就不会被垃圾回收。</div><div class="line">　　但WeakHashMap的key只保留了对实际对象的弱引用，这意味着如果WeakHashMap对象的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，当垃</div><div class="line">　　圾回收了该key所对应的实际对象之后，WeakHashMap也可能自动删除这些key所对应的key-value对</div><div class="line">    5) IdentityHashMap</div><div class="line">    IdentityHashMap的实现机制与HashMap基本相似，在IdentityHashMap中，当且仅当两个key严格相等(key1 == key2)时，IdentityHashMap才认为两个key相等</div><div class="line">    6) EnumMap</div><div class="line">    EnumMap是一个与枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值。创建EnumMap时必须显式或隐式指定它对应的枚举类。EnumMap根据key的自然顺序</div><div class="line">　　(即枚举值在枚举类中的定义顺序)</div></pre></td></tr></table></figure>
<p><img src="http://images.cnitblog.com/i/532548/201404/262238192165666.jpg" alt="img"></p>
<p><strong>3. Java集合类的应用场景代码</strong></p>
<p>学习了集合类的基本架构框架之后，我们接着来学习它们各自的应用场景、以及细节处的注意事项</p>
<p><strong>0x1: Set</strong></p>
<p><strong>*HashSet*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">import java.util.*; </div><div class="line"></div><div class="line">//类A的equals方法总是返回true,但没有重写其hashCode()方法。不能保证当前对象是HashSet中的唯一对象</div><div class="line">class A</div><div class="line">&#123;</div><div class="line">    public boolean equals(Object obj)</div><div class="line">    &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//类B的hashCode()方法总是返回1,但没有重写其equals()方法。不能保证当前对象是HashSet中的唯一对象</div><div class="line">class B</div><div class="line">&#123;</div><div class="line">    public int hashCode()</div><div class="line">    &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//类C的hashCode()方法总是返回2,且有重写其equals()方法</div><div class="line">class C</div><div class="line">&#123;</div><div class="line">    public int hashCode()</div><div class="line">    &#123;</div><div class="line">        return 2;</div><div class="line">    &#125;</div><div class="line">    public boolean equals(Object obj)</div><div class="line">    &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class HashSetTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        HashSet books = new HashSet();</div><div class="line">        //分别向books集合中添加两个A对象，两个B对象，两个C对象</div><div class="line">        books.add(new A());</div><div class="line">        books.add(new A());</div><div class="line"></div><div class="line">        books.add(new B());</div><div class="line">        books.add(new B());</div><div class="line"></div><div class="line">        books.add(new C());</div><div class="line">        books.add(new C());</div><div class="line">        System.out.println(books);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>result:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[B@1, B@1, C@2, A@3bc257, A@785d65]</div></pre></td></tr></table></figure>
<p>可以看到，如果两个对象通过equals()方法比较返回true，但这两个对象的hashCode()方法返回不同的hashCode值时，这将导致HashSet会把这两个对象保存在Hash表的不同位置，从而使对象可以添加成功，这就与Set集合的规则有些出入了。所以，我们要明确的是: equals()决定是否可以加入HashSet、而hashCode()决定存放的位置，它们两者必须同时满足才能允许一个新元素加入HashSet<br>但是要注意的是: 如果两个对象的hashCode相同，但是它们的equlas返回值不同，HashSet会在这个位置用链式结构来保存多个对象。而HashSet访问集合元素时也是根据元素的HashCode值来快速定位的，这种链式结构会导致性能下降。</p>
<p>所以如果需要把某个类的对象保存到HashSet集合中，我们在重写这个类的equlas()方法和hashCode()方法时，应该尽量保证两个对象通过equals()方法比较返回true时，它们的hashCode()方法返回值也相等</p>
<p><strong>*LinkedHashSet*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import java.util.*; </div><div class="line"></div><div class="line">public class LinkedHashSetTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        LinkedHashSet books = new LinkedHashSet();</div><div class="line">        books.add(&quot;Java&quot;);</div><div class="line">        books.add(&quot;LittleHann&quot;);</div><div class="line">        System.out.println(books);</div><div class="line"></div><div class="line">        //删除 Java</div><div class="line">      books.remove(&quot;Java&quot;);</div><div class="line">        //重新添加 Java</div><div class="line">        books.add(&quot;Java&quot;);</div><div class="line">        System.out.println(books);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>元素的顺序总是与添加顺序一致，同时要明白的是，LinkedHashSetTest是HashSet的子类，因此它不允许集合元素重复</p>
<p><strong>*TreeSet*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class TreeSetTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        TreeSet nums = new TreeSet();</div><div class="line">        //向TreeSet中添加四个Integer对象</div><div class="line">        nums.add(5);</div><div class="line">        nums.add(2);</div><div class="line">        nums.add(10);</div><div class="line">        nums.add(-9);</div><div class="line"></div><div class="line">        //输出集合元素，看到集合元素已经处于排序状态</div><div class="line">        System.out.println(nums);</div><div class="line"></div><div class="line">        //输出集合里的第一个元素</div><div class="line">        System.out.println(nums.first());</div><div class="line"></div><div class="line">        //输出集合里的最后一个元素</div><div class="line">        System.out.println(nums.last());</div><div class="line"></div><div class="line">        //返回小于4的子集，不包含4</div><div class="line">        System.out.println(nums.headSet(4));</div><div class="line"></div><div class="line">        //返回大于5的子集，如果Set中包含5，子集中还包含5</div><div class="line">        System.out.println(nums.tailSet(5));</div><div class="line"></div><div class="line">        //返回大于等于-3，小于4的子集。</div><div class="line">        System.out.println(nums.subSet(-3 , 4));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与HashSet集合采用hash算法来决定元素的存储位置不同，TreeSet采用红黑树的数据结构来存储集合元素。TreeSet支持两种排序方式: 自然排序、定制排序</p>
<p><strong>1. 自然排序:</strong></p>
<p>TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排序，即自然排序。如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，否则程序会抛出异常。</p>
<p>当把一个对象加入TreeSet集合中时，TreeSet会调用该对象的compareTo(Object obj)方法与容器中的其他对象比较大小，然后根据红黑树结构找到它的存储位置。如果两个对象通过compareTo(Object obj)方法比较相等，新对象将无法添加到TreeSet集合中(牢记Set是不允许重复的概念)。</p>
<p>注意: 当需要把一个对象放入TreeSet中，重写该对象对应类的equals()方法时，应该保证该方法与compareTo(Object obj)方法有一致的结果，即如果两个对象通过equals()方法比较返回true时，这两个对象通过compareTo(Object obj)方法比较结果应该也为0(即相等)</p>
<p>看到这里，我们应该明白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1) 对与Set来说，它定义了equals()为唯一性判断的标准，而对于到了具体的实现，HashSet、TreeSet来说，它们又会有自己特有的唯一性判断标准，只有同时满足了才能判定为唯一性</div><div class="line">2) 我们在操作这些集合类的时候，对和唯一性判断有关的函数重写要重点关注</div></pre></td></tr></table></figure>
<p><strong> 2. 定制排序</strong></p>
<p>TreeSet的自然排序是根据集合元素的大小，TreeSet将它们以升序排序。如果我们需要实现定制排序，则可以通过Comparator接口的帮助(类似PHP中的array_map回调处理函数的思想)。该接口里包含一个int compare(T o1， T o2)方法，该方法用于比较大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">class M</div><div class="line">&#123;</div><div class="line">    int age;</div><div class="line">    public M(int age)</div><div class="line">    &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">    public String toString()</div><div class="line">    &#123;</div><div class="line">        return &quot;M[age:&quot; + age + &quot;]&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TreeSetTest4</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        TreeSet ts = new TreeSet(new Comparator()</div><div class="line">        &#123;</div><div class="line">            //根据M对象的age属性来决定大小</div><div class="line">            public int compare(Object o1, Object o2)</div><div class="line">            &#123;</div><div class="line">                M m1 = (M)o1;</div><div class="line">                M m2 = (M)o2;</div><div class="line">                return m1.age &gt; m2.age ? -1</div><div class="line">                    : m1.age &lt; m2.age ? 1 : 0;</div><div class="line">            &#125;</div><div class="line">        &#125;);    </div><div class="line">        ts.add(new M(5));</div><div class="line">        ts.add(new M(-3));</div><div class="line">        ts.add(new M(9));</div><div class="line">        System.out.println(ts);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到这里，我们需要梳理一下关于排序的概念</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) equals、compareTo决定的是怎么比的问题，即用什么field进行大小比较</div><div class="line">2) 自然排序、定制排序、Comparator决定的是谁大的问题，即按什么顺序(升序、降序)进行排序</div><div class="line">它们的关注点是不同的，一定要注意区分</div></pre></td></tr></table></figure>
<p><strong>*EnumSet*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">enum Season</div><div class="line">&#123;</div><div class="line">    SPRING,SUMMER,FALL,WINTER</div><div class="line">&#125;</div><div class="line">public class EnumSetTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        //创建一个EnumSet集合，集合元素就是Season枚举类的全部枚举值</div><div class="line">        EnumSet es1 = EnumSet.allOf(Season.class);</div><div class="line">        //输出[SPRING,SUMMER,FALL,WINTER]</div><div class="line">        System.out.println(es1);</div><div class="line"></div><div class="line">        //创建一个EnumSet空集合，指定其集合元素是Season类的枚举值。</div><div class="line">        EnumSet es2 = EnumSet.noneOf(Season.class); </div><div class="line">        //输出[]</div><div class="line">        System.out.println(es2); </div><div class="line">        //手动添加两个元素</div><div class="line">        es2.add(Season.WINTER);</div><div class="line">        es2.add(Season.SPRING);</div><div class="line">        //输出[SPRING,WINTER]</div><div class="line">        System.out.println(es2);</div><div class="line"></div><div class="line">        //以指定枚举值创建EnumSet集合</div><div class="line">        EnumSet es3 = EnumSet.of(Season.SUMMER , Season.WINTER); </div><div class="line">        //输出[SUMMER,WINTER]</div><div class="line">        System.out.println(es3);</div><div class="line"></div><div class="line">        EnumSet es4 = EnumSet.range(Season.SUMMER , Season.WINTER); </div><div class="line">        //输出[SUMMER,FALL,WINTER]</div><div class="line">        System.out.println(es4);</div><div class="line"></div><div class="line">        //新创建的EnumSet集合的元素和es4集合的元素有相同类型，</div><div class="line">        //es5的集合元素 + es4集合元素 = Season枚举类的全部枚举值</div><div class="line">        EnumSet es5 = EnumSet.complementOf(es4); </div><div class="line">        //输出[SPRING]</div><div class="line">        System.out.println(es5);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是Set集合类的编程应用场景。那么应该怎样选择何时使用这些集合类呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1) HashSet的性能总是比TreeSet好(特别是最常用的添加、查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet</div><div class="line">2) 对于普通的插入、删除操作，LinkedHashSet比HashSet要略慢一点，这是由维护链表所带来的开销造成的。不过，因为有了链表的存在，遍历LinkedHashSet会更快</div><div class="line">3) EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素</div><div class="line">4) HashSet、TreeSet、EnumSet都是&quot;线程不安全&quot;的，通常可以通过Collections工具类的synchronizedSortedSet方法来&quot;包装&quot;该Set集合。</div><div class="line">SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));</div></pre></td></tr></table></figure>
<p><strong>0x2: List</strong></p>
<p><strong>*ArrayList*</strong></p>
<p>如果一开始就知道ArrayList集合需要保存多少元素，则可以在创建它们时就指定initialCapacity大小，这样可以减少重新分配的次数，提供性能，ArrayList还提供了如下方法来重新分配Object[]数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1) ensureCapacity(int minCapacity): 将ArrayList集合的Object[]数组长度增加minCapacity</div><div class="line">2) trimToSize(): 调整ArrayList集合的Object[]数组长度为当前元素的个数。程序可以通过此方法来减少ArrayList集合对象占用的内存空间</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class ListTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        List books = new ArrayList();</div><div class="line">        //向books集合中添加三个元素</div><div class="line">        books.add(new String(&quot;轻量级Java EE企业应用实战&quot;));</div><div class="line">        books.add(new String(&quot;疯狂Java讲义&quot;));</div><div class="line">        books.add(new String(&quot;疯狂Android讲义&quot;));</div><div class="line">        System.out.println(books);</div><div class="line"></div><div class="line">        //将新字符串对象插入在第二个位置</div><div class="line">        books.add(1 , new String(&quot;疯狂Ajax讲义&quot;));</div><div class="line">        for (int i = 0 ; i &lt; books.size() ; i++ )</div><div class="line">        &#123;</div><div class="line">            System.out.println(books.get(i));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //删除第三个元素</div><div class="line">        books.remove(2);</div><div class="line">        System.out.println(books);</div><div class="line"></div><div class="line">        //判断指定元素在List集合中位置：输出1，表明位于第二位</div><div class="line">        System.out.println(books.indexOf(new String(&quot;疯狂Ajax讲义&quot;)));  //①</div><div class="line">        //将第二个元素替换成新的字符串对象</div><div class="line">        books.set(1, new String(&quot;LittleHann&quot;));</div><div class="line">        System.out.println(books);</div><div class="line"></div><div class="line">        //将books集合的第二个元素（包括）</div><div class="line">        //到第三个元素（不包括）截取成子集合</div><div class="line">        System.out.println(books.subList(1 , 2));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong><em>Stack</em></strong></p>
<p>注意Stack的后进先出的特点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class VectorTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        Stack v = new Stack();</div><div class="line">        //依次将三个元素push入&quot;栈&quot;</div><div class="line">        v.push(&quot;疯狂Java讲义&quot;);</div><div class="line">        v.push(&quot;轻量级Java EE企业应用实战&quot;);</div><div class="line">        v.push(&quot;疯狂Android讲义&quot;);</div><div class="line"></div><div class="line">        //输出：[疯狂Java讲义, 轻量级Java EE企业应用实战 , 疯狂Android讲义]</div><div class="line">        System.out.println(v);</div><div class="line"></div><div class="line">        //访问第一个元素，但并不将其pop出&quot;栈&quot;，输出：疯狂Android讲义</div><div class="line">        System.out.println(v.peek());</div><div class="line"></div><div class="line">        //依然输出：[疯狂Java讲义, 轻量级Java EE企业应用实战 , 疯狂Android讲义]</div><div class="line">        System.out.println(v);</div><div class="line"></div><div class="line">        //pop出第一个元素，输出：疯狂Android讲义</div><div class="line">        System.out.println(v.pop());</div><div class="line"></div><div class="line">        //输出：[疯狂Java讲义, 轻量级Java EE企业应用实战]</div><div class="line">        System.out.println(v);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>*LinkedList*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class LinkedListTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        LinkedList books = new LinkedList();</div><div class="line"></div><div class="line">        //将字符串元素加入队列的尾部(双端队列)</div><div class="line">        books.offer(&quot;疯狂Java讲义&quot;);</div><div class="line"></div><div class="line">        //将一个字符串元素加入栈的顶部(双端队列)</div><div class="line">        books.push(&quot;轻量级Java EE企业应用实战&quot;);</div><div class="line"></div><div class="line">        //将字符串元素添加到队列的头(相当于栈的顶部)</div><div class="line">        books.offerFirst(&quot;疯狂Android讲义&quot;);</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; books.size() ; i++ )</div><div class="line">        &#123;</div><div class="line">            System.out.println(books.get(i));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //访问、并不删除栈顶的元素</div><div class="line">        System.out.println(books.peekFirst());</div><div class="line">        //访问、并不删除队列的最后一个元素</div><div class="line">        System.out.println(books.peekLast());</div><div class="line">        //将栈顶的元素弹出&quot;栈&quot;</div><div class="line">        System.out.println(books.pop());</div><div class="line">        //下面输出将看到队列中第一个元素被删除</div><div class="line">        System.out.println(books);</div><div class="line">        //访问、并删除队列的最后一个元素</div><div class="line">        System.out.println(books.pollLast());</div><div class="line">        //下面输出将看到队列中只剩下中间一个元素：</div><div class="line">        //轻量级Java EE企业应用实战</div><div class="line">        System.out.println(books);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中我们可以看到，LinkedList同时表现出了双端队列、栈的用法。功能非常强大</p>
<p><strong>0x3: Queue</strong></p>
<p><strong>*PriorityQueue*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class PriorityQueueTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        PriorityQueue pq = new PriorityQueue();</div><div class="line">        //下面代码依次向pq中加入四个元素</div><div class="line">        pq.offer(6);</div><div class="line">        pq.offer(-3);</div><div class="line">        pq.offer(9);</div><div class="line">        pq.offer(0);</div><div class="line"></div><div class="line">        //输出pq队列，并不是按元素的加入顺序排列，</div><div class="line">        //而是按元素的大小顺序排列，输出[-3, 0, 9, 6]</div><div class="line">        System.out.println(pq);</div><div class="line">        //访问队列第一个元素，其实就是队列中最小的元素：-3</div><div class="line">        System.out.println(pq.poll());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PriorityQueue不允许插入null元素，它还需要对队列元素进行排序，PriorityQueue的元素有两种排序方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1) 自然排序:</div><div class="line">采用自然顺序的PriorityQueue集合中的元素对象都必须实现了Comparable接口，而且应该是同一个类的多个实例，否则可能导致ClassCastException异常</div><div class="line">2) 定制排序</div><div class="line">创建PriorityQueue队列时，传入一个Comparator对象，该对象负责对队列中的所有元素进行排序</div><div class="line">关于自然排序、定制排序的原理和之前说的TreeSet类似</div></pre></td></tr></table></figure>
<p><strong>* ArrayDeque*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class ArrayDequeTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        ArrayDeque stack = new ArrayDeque();</div><div class="line">        //依次将三个元素push入&quot;栈&quot;</div><div class="line">        stack.push(&quot;疯狂Java讲义&quot;);</div><div class="line">        stack.push(&quot;轻量级Java EE企业应用实战&quot;);</div><div class="line">        stack.push(&quot;疯狂Android讲义&quot;);</div><div class="line"></div><div class="line">        //输出：[疯狂Java讲义, 轻量级Java EE企业应用实战 , 疯狂Android讲义]</div><div class="line">        System.out.println(stack);</div><div class="line"></div><div class="line">        //访问第一个元素，但并不将其pop出&quot;栈&quot;，输出：疯狂Android讲义</div><div class="line">        System.out.println(stack.peek());</div><div class="line"></div><div class="line">        //依然输出：[疯狂Java讲义, 轻量级Java EE企业应用实战 , 疯狂Android讲义]</div><div class="line">        System.out.println(stack);</div><div class="line"></div><div class="line">        //pop出第一个元素，输出：疯狂Android讲义</div><div class="line">        System.out.println(stack.pop());</div><div class="line"></div><div class="line">        //输出：[疯狂Java讲义, 轻量级Java EE企业应用实战]</div><div class="line">        System.out.println(stack);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是List集合类的编程应用场景。我们来梳理一下思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. java提供的List就是一个&quot;线性表接口&quot;，ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)是线性表的两种典型实现</div><div class="line">2. Queue代表了队列，Deque代表了双端队列(既可以作为队列使用、也可以作为栈使用)</div><div class="line">3. 因为数组以一块连续内存来保存所有的数组元素，所以数组在随机访问时性能最好。所以的内部以数组作为底层实现的集合在随机访问时性能最好。</div><div class="line">4. 内部以链表作为底层实现的集合在执行插入、删除操作时有很好的性能</div><div class="line">5. 进行迭代操作时，以链表作为底层实现的集合比以数组作为底层实现的集合性能好</div></pre></td></tr></table></figure>
<p>我们之前说过，Collection接口继承了Iterable接口，也就是说，我们以上学习到的所有的Collection集合类都具有”可遍历性”</p>
<p>Iterable接口也是java集合框架的成员，它隐藏了各种Collection实现类的底层细节，向应用程序提供了遍历Collection集合元素的统一编程接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) boolean hasNext(): 是否还有下一个未遍历过的元素</div><div class="line">2) Object next(): 返回集合里的下一个元素</div><div class="line">3) void remove(): 删除集合里上一次next方法返回的元素</div></pre></td></tr></table></figure>
<p><strong>iterator实现遍历:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class IteratorTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        //创建一个集合</div><div class="line">        Collection books = new HashSet();</div><div class="line">        books.add(&quot;轻量级Java EE企业应用实战&quot;);</div><div class="line">        books.add(&quot;疯狂Java讲义&quot;);</div><div class="line">        books.add(&quot;疯狂Android讲义&quot;);</div><div class="line"></div><div class="line"></div><div class="line">        //获取books集合对应的迭代器</div><div class="line">        Iterator it = books.iterator();</div><div class="line">        while(it.hasNext())</div><div class="line">        &#123;</div><div class="line">            //it.next()方法返回的数据类型是Object类型，</div><div class="line">            //需要强制类型转换</div><div class="line">            String book = (String)it.next();</div><div class="line">            System.out.println(book);</div><div class="line">            if (book.equals(&quot;疯狂Java讲义&quot;))</div><div class="line">            &#123;</div><div class="line">                //从集合中删除上一次next方法返回的元素</div><div class="line">                it.remove();</div><div class="line">            &#125;</div><div class="line">            //对book变量赋值，不会改变集合元素本身</div><div class="line">            book = &quot;测试字符串&quot;;    </div><div class="line">        &#125;</div><div class="line">        System.out.println(books);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码可以看出，iterator必须依附于Collection对象，若有一个iterator对象，必然有一个与之关联的Collection对象。</p>
<p>除了可以使用iterator接口迭代访问Collection集合里的元素之外，使用java5提供的foreach循环迭代访问集合元素更加便捷</p>
<p><strong>foreach实现遍历:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class ForeachTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        //创建一个集合</div><div class="line">        Collection books = new HashSet();</div><div class="line">        books.add(new String(&quot;轻量级Java EE企业应用实战&quot;));</div><div class="line">        books.add(new String(&quot;疯狂Java讲义&quot;));</div><div class="line">        books.add(new String(&quot;疯狂Android讲义&quot;));</div><div class="line"></div><div class="line">        for (Object obj : books)</div><div class="line">        &#123;</div><div class="line">            //此处的book变量也不是集合元素本身</div><div class="line">            String book = (String)obj;</div><div class="line">            System.out.println(book);</div><div class="line">            if (book.equals(&quot;疯狂Android讲义&quot;))</div><div class="line">            &#123;</div><div class="line">                //下面代码会引发ConcurrentModificationException异常</div><div class="line">                //books.remove(book);      </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(books);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了Collection固有的iterator()方法，List还额外提供了一个listIterator()方法，该方法返回一个ListIterator对象，ListIterator接口继承了Iterator接口，提供了专门操作List的方法。ListIterator接口在Iterator接口的继承上增加了如下方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) boolean hasPrevious(): 返回该迭代器关联的集合是否还有上一个元素</div><div class="line">2) Object previous(): 返回该迭代器的上一个元素(向前迭代)</div><div class="line">3) void add(): 在指定位置插入一个元素</div></pre></td></tr></table></figure>
<p><strong>ListIterator实现遍历:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class ListIteratorTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        String[] books = &#123;</div><div class="line">            &quot;疯狂Java讲义&quot;,</div><div class="line">            &quot;轻量级Java EE企业应用实战&quot;</div><div class="line">        &#125;;</div><div class="line">        List bookList = new ArrayList();</div><div class="line">        for (int i = 0; i &lt; books.length ; i++ )</div><div class="line">        &#123;</div><div class="line">            bookList.add(books[i]);</div><div class="line">        &#125;</div><div class="line">        ListIterator lit = bookList.listIterator();</div><div class="line">        while (lit.hasNext())</div><div class="line">        &#123;</div><div class="line">            System.out.println(lit.next());</div><div class="line">            lit.add(&quot;-------分隔符-------&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;=======下面开始反向迭代=======&quot;);</div><div class="line">        while(lit.hasPrevious())</div><div class="line">        &#123;</div><div class="line">            System.out.println(lit.previous());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>0x4: Map</strong></p>
<p><strong>*HashMap、Hashtable*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">class A</div><div class="line">&#123;</div><div class="line">    int count;</div><div class="line">    public A(int count)</div><div class="line">    &#123;</div><div class="line">        this.count = count;</div><div class="line">    &#125;</div><div class="line">    //根据count的值来判断两个对象是否相等。</div><div class="line">    public boolean equals(Object obj)</div><div class="line">    &#123;</div><div class="line">        if (obj == this)</div><div class="line">            return true;</div><div class="line">        if (obj!=null &amp;&amp;</div><div class="line">            obj.getClass()==A.class)</div><div class="line">        &#123;</div><div class="line">            A a = (A)obj;</div><div class="line">            return this.count == a.count;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    //根据count来计算hashCode值。</div><div class="line">    public int hashCode()</div><div class="line">    &#123;</div><div class="line">        return this.count;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class B</div><div class="line">&#123;</div><div class="line">    //重写equals()方法，B对象与任何对象通过equals()方法比较都相等</div><div class="line">    public boolean equals(Object obj)</div><div class="line">    &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class HashtableTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        Hashtable ht = new Hashtable();</div><div class="line">        ht.put(new A(60000) , &quot;疯狂Java讲义&quot;);</div><div class="line">        ht.put(new A(87563) , &quot;轻量级Java EE企业应用实战&quot;);</div><div class="line">        ht.put(new A(1232) , new B());</div><div class="line">        System.out.println(ht);</div><div class="line"></div><div class="line">        //只要两个对象通过equals比较返回true，</div><div class="line">        //Hashtable就认为它们是相等的value。</div><div class="line">        //由于Hashtable中有一个B对象，</div><div class="line">        //它与任何对象通过equals比较都相等，所以下面输出true。</div><div class="line">        System.out.println(ht.containsValue(&quot;测试字符串&quot;));  //①</div><div class="line"></div><div class="line">        //只要两个A对象的count相等，它们通过equals比较返回true，且hashCode相等</div><div class="line">        //Hashtable即认为它们是相同的key，所以下面输出true。</div><div class="line">        System.out.println(ht.containsKey(new A(87563)));   //②</div><div class="line"></div><div class="line">        //下面语句可以删除最后一个key-value对</div><div class="line">        ht.remove(new A(1232));    //③</div><div class="line"></div><div class="line">        //通过返回Hashtable的所有key组成的Set集合，</div><div class="line">        //从而遍历Hashtable每个key-value对</div><div class="line">        for (Object key : ht.keySet())</div><div class="line">        &#123;</div><div class="line">            System.out.print(key + &quot;----&gt;&quot;);</div><div class="line">            System.out.print(ht.get(key) + &quot;\n&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当使用自定义类作为HashMap、Hashtable的key时，如果重写该类的equals(Object obj)和hashCode()方法，则应该保证两个方法的判断标准一致–当两个key通过equals()方法比较返回true时，两个key的hashCode()的返回值也应该相同</p>
<p><strong>*LinkedHashMap*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class LinkedHashMapTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        LinkedHashMap scores = new LinkedHashMap();</div><div class="line">        scores.put(&quot;语文&quot; , 80);</div><div class="line">        scores.put(&quot;英文&quot; , 82);</div><div class="line">        scores.put(&quot;数学&quot; , 76);</div><div class="line">        //遍历scores里的所有的key-value对</div><div class="line">        for (Object key : scores.keySet())</div><div class="line">        &#123;</div><div class="line">            System.out.println(key + &quot;------&gt;&quot; + scores.get(key));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>*Properties*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">public class PropertiesTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) throws Exception</div><div class="line">    &#123;</div><div class="line">        Properties props = new Properties();</div><div class="line">        //向Properties中增加属性</div><div class="line">        props.setProperty(&quot;username&quot; , &quot;yeeku&quot;);</div><div class="line">        props.setProperty(&quot;password&quot; , &quot;123456&quot;);</div><div class="line"></div><div class="line">        //将Properties中的key-value对保存到a.ini文件中</div><div class="line">        props.store(new FileOutputStream(&quot;a.ini&quot;), &quot;comment line&quot;);   //①</div><div class="line"></div><div class="line">        //新建一个Properties对象</div><div class="line">        Properties props2 = new Properties();</div><div class="line">        //向Properties中增加属性</div><div class="line">        props2.setProperty(&quot;gender&quot; , &quot;male&quot;);</div><div class="line"></div><div class="line">        //将a.ini文件中的key-value对追加到props2中</div><div class="line">        props2.load(new FileInputStream(&quot;a.ini&quot;) );    //②</div><div class="line">        System.out.println(props2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Properties还可以把key-value对以XML文件的形式保存起来，也可以从XML文件中加载key-value对</p>
<p><strong>*TreeMap*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">class R implements Comparable</div><div class="line">&#123;</div><div class="line">    int count;</div><div class="line">    public R(int count)</div><div class="line">    &#123;</div><div class="line">        this.count = count;</div><div class="line">    &#125;</div><div class="line">    public String toString()</div><div class="line">    &#123;</div><div class="line">        return &quot;R[count:&quot; + count + &quot;]&quot;;</div><div class="line">    &#125;</div><div class="line">    //根据count来判断两个对象是否相等。</div><div class="line">    public boolean equals(Object obj)</div><div class="line">    &#123;</div><div class="line">        if (this == obj)</div><div class="line">            return true;</div><div class="line">        if (obj!=null</div><div class="line">            &amp;&amp; obj.getClass()==R.class)</div><div class="line">        &#123;</div><div class="line">            R r = (R)obj;</div><div class="line">            return r.count == this.count;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    //根据count属性值来判断两个对象的大小。</div><div class="line">    public int compareTo(Object obj)</div><div class="line">    &#123;</div><div class="line">        R r = (R)obj;</div><div class="line">        return count &gt; r.count ? 1 :</div><div class="line">            count &lt; r.count ? -1 : 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class TreeMapTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        TreeMap tm = new TreeMap();</div><div class="line">        tm.put(new R(3) , &quot;轻量级Java EE企业应用实战&quot;);</div><div class="line">        tm.put(new R(-5) , &quot;疯狂Java讲义&quot;);</div><div class="line">        tm.put(new R(9) , &quot;疯狂Android讲义&quot;);</div><div class="line"></div><div class="line">        System.out.println(tm);</div><div class="line"></div><div class="line">        //返回该TreeMap的第一个Entry对象</div><div class="line">        System.out.println(tm.firstEntry());</div><div class="line"></div><div class="line">        //返回该TreeMap的最后一个key值</div><div class="line">        System.out.println(tm.lastKey());</div><div class="line"></div><div class="line">        //返回该TreeMap的比new R(2)大的最小key值。</div><div class="line">        System.out.println(tm.higherKey(new R(2)));</div><div class="line"></div><div class="line">        //返回该TreeMap的比new R(2)小的最大的key-value对。</div><div class="line">        System.out.println(tm.lowerEntry(new R(2)));</div><div class="line"></div><div class="line">        //返回该TreeMap的子TreeMap</div><div class="line">        System.out.println(tm.subMap(new R(-1) , new R(4)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，类似于TreeSet中判断两个元素是否相等的标准，TreeMap中判断两个key相等的标准是: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1) 两个key通过compareTo()方法返回0</div><div class="line">2) equals()放回true</div></pre></td></tr></table></figure>
<p>我们在重写这两个方法的时候一定要保证它们的逻辑关系一致。</p>
<p>再次强调一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set和Map的关系十分密切，java源码就是先实现了HashMap、TreeMap等集合，然后通过包装一个所有的value都为null的Map集合实现了Set集合类</div></pre></td></tr></table></figure>
<p><strong>*WeakHashMap*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class WeakHashMapTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        WeakHashMap whm = new WeakHashMap();</div><div class="line">        //将WeakHashMap中添加三个key-value对，</div><div class="line">        //三个key都是匿名字符串对象（没有其他引用）</div><div class="line">        whm.put(new String(&quot;语文&quot;) , new String(&quot;良好&quot;));</div><div class="line">        whm.put(new String(&quot;数学&quot;) , new String(&quot;及格&quot;));</div><div class="line">        whm.put(new String(&quot;英文&quot;) , new String(&quot;中等&quot;));</div><div class="line"></div><div class="line">        //将WeakHashMap中添加一个key-value对，</div><div class="line">        //该key是一个系统缓存的字符串对象。&quot;java&quot;是一个常量字符串强引用</div><div class="line">        whm.put(&quot;java&quot; , new String(&quot;中等&quot;));</div><div class="line">        //输出whm对象，将看到4个key-value对。</div><div class="line">        System.out.println(whm);</div><div class="line">        //通知系统立即进行垃圾回收</div><div class="line">        System.gc();</div><div class="line">        System.runFinalization();</div><div class="line">        //通常情况下，将只看到一个key-value对。</div><div class="line">        System.out.println(whm);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果需要使用WeakHashMap的key来保留对象的弱引用，则不要让key所引用的对象具有任何强引用，否则将失去使用WeakHashMap的意义</p>
<p><strong>*IdentityHashMap*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class IdentityHashMapTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        IdentityHashMap ihm = new IdentityHashMap();</div><div class="line">        //下面两行代码将会向IdentityHashMap对象中添加两个key-value对</div><div class="line">        ihm.put(new String(&quot;语文&quot;) , 89);</div><div class="line">        ihm.put(new String(&quot;语文&quot;) , 78);</div><div class="line"></div><div class="line">        //下面两行代码只会向IdentityHashMap对象中添加一个key-value对</div><div class="line">        ihm.put(&quot;java&quot; , 93);</div><div class="line">        ihm.put(&quot;java&quot; , 98);</div><div class="line">        System.out.println(ihm);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>*EnumMap*</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">enum Season</div><div class="line">&#123;</div><div class="line">    SPRING,SUMMER,FALL,WINTER</div><div class="line">&#125;</div><div class="line">public class EnumMapTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) </div><div class="line">    &#123;</div><div class="line">        //创建一个EnumMap对象，该EnumMap的所有key</div><div class="line">        //必须是Season枚举类的枚举值</div><div class="line">        EnumMap enumMap = new EnumMap(Season.class);</div><div class="line">        enumMap.put(Season.SUMMER , &quot;夏日炎炎&quot;);</div><div class="line">        enumMap.put(Season.SPRING , &quot;春暖花开&quot;);</div><div class="line">        System.out.println(enumMap);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与创建普通Map有所区别的是，创建EnumMap是必须指定一个枚举类，从而将该EnumMap和指定枚举类关联起来</p>
<p>以上就是Map集合类的编程应用场景。我们来梳理一下思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) HashMap和Hashtable的效率大致相同，因为它们的实现机制几乎完全一样。但HashMap通常比Hashtable要快一点，因为Hashtable需要额外的线程同步控制</div><div class="line">2) TreeMap通常比HashMap、Hashtable要慢(尤其是在插入、删除key-value对时更慢)，因为TreeMap底层采用红黑树来管理key-value对</div><div class="line">3) 使用TreeMap的一个好处就是： TreeMap中的key-value对总是处于有序状态，无须专门进行排序操作</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2017/05/06/java-collections/" class="article-date">
  <time datetime="2017-05-05T18:15:46.000Z" itemprop="datePublished">2017-05-06</time>
</a>

        </li>
        
          <li>
            <span class="label">Category:</span>
            
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>


          </li>
        
        
          <li>
            <span class="label">Tag:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>


          </li>
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2017/05/15/docker-kibana/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          docker构建kibana
        
      </div>
    </a>
  
  
    <a href="/2017/05/05/ubuntu-nginx/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ubuntu编译安装nginx</div>
    </a>
  
</nav>


  
</article>




      </div>
      
    <footer id="footer" class="post-footer footer">
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>闲步山雨后,静待晚林风 Post</p>


      </div>
    </footer>

      

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
