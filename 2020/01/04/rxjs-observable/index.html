<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>rxjs之Observable | Ace&#39;pages</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Observable（可观察对象）是基于推送（Push）运行时执行（lazy）的多值集合。下方表格对Observable进行了定位（为解决基于推送的多值问题）：    MagicQ 单值 多值     拉取(Pull) 函数 遍历器   推送(Push) Promise Observable    例：当observable被订阅后，会立即（同步地）推送1， 2， 3 三个值；1秒之后，继续推送4">
<meta property="og:type" content="article">
<meta property="og:title" content="rxjs之Observable">
<meta property="og:url" content="http://hujao.com/2020/01/04/rxjs-observable/index.html">
<meta property="og:site_name" content="Ace&#39;pages">
<meta property="og:description" content="Observable（可观察对象）是基于推送（Push）运行时执行（lazy）的多值集合。下方表格对Observable进行了定位（为解决基于推送的多值问题）：    MagicQ 单值 多值     拉取(Pull) 函数 遍历器   推送(Push) Promise Observable    例：当observable被订阅后，会立即（同步地）推送1， 2， 3 三个值；1秒之后，继续推送4">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-01-04T02:28:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="rxjs之Observable">
<meta name="twitter:description" content="Observable（可观察对象）是基于推送（Push）运行时执行（lazy）的多值集合。下方表格对Observable进行了定位（为解决基于推送的多值问题）：    MagicQ 单值 多值     拉取(Pull) 函数 遍历器   推送(Push) Promise Observable    例：当observable被订阅后，会立即（同步地）推送1， 2， 3 三个值；1秒之后，继续推送4">
  
    <link rel="alternate" href="/atom.xml" title="Ace&#39;pages" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
</head>
</html>
  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-rxjs-observable" class="article article-type-post" itemscope="" itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/tags/docker">Docker</a>
    
      <a class="main-nav-link" href="/tags/springboot">SpringBoot</a>
    
      <a class="main-nav-link" href="/tags/elasticsearch">ElasticSearch</a>
    
      <a class="main-nav-link" href="/tags/test">Test</a>
    
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
    
  </nav>
</header>

  <hr>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      rxjs之Observable
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <p>Observable（<strong>可观察对象</strong>）是基于推送（<strong>Push</strong>）运行时执行（<strong>lazy</strong>）的多值集合。下方表格对Observable进行了定位（<em>为解决基于推送的多值问题</em>）：</p>
<table>
<thead>
<tr>
<th>MagicQ</th>
<th>单值</th>
<th>多值</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>拉取(Pull)</strong></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Glossary/Function" target="_blank" rel="noopener"><code>函数</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="noopener">遍历器</a></td>
</tr>
<tr>
<td><strong>推送(Push)</strong></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise" target="_blank" rel="noopener"><code>Promise</code></a></td>
<td><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html" target="_blank" rel="noopener"><code>Observable</code></a></td>
</tr>
</tbody>
</table>
<p><strong>例</strong>：当<code>observable</code>被订阅后，会立即（<em>同步地</em>）推送<code>1</code>， <code>2</code>， <code>3</code> 三个值；1秒之后，继续推送<code>4</code>这个值，最后结束（<em>推送结束通知</em>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  observer.next(<span class="number">1</span>);</span><br><span class="line">  observer.next(<span class="number">2</span>);</span><br><span class="line">  observer.next(<span class="number">3</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(<span class="number">4</span>);</span><br><span class="line">    observer.complete();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>为得到<code>observable</code>推送的值，我们需要订阅（<em>subscribe</em>）这个Observable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  observer.next(<span class="number">1</span>);</span><br><span class="line">  observer.next(<span class="number">2</span>);</span><br><span class="line">  observer.next(<span class="number">3</span>);j<span class="string">'s</span></span><br><span class="line"><span class="string">  setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="string">    observer.next(4);</span></span><br><span class="line"><span class="string">    observer.complete();</span></span><br><span class="line"><span class="string">  &#125;, 1000);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log('</span>just before subscribe<span class="string">');</span></span><br><span class="line"><span class="string">observable.subscribe(&#123;</span></span><br><span class="line"><span class="string">  next: x =&gt; console.log('</span>got value <span class="string">' + x),</span></span><br><span class="line"><span class="string">  error: err =&gt; console.error('</span>something wrong occurred: <span class="string">' + err),</span></span><br><span class="line"><span class="string">  complete: () =&gt; console.log('</span>done<span class="string">'),</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">console.log('</span>just after subscribe<span class="string">');</span></span><br></pre></td></tr></table></figure>
<p>程序执行后，将在控制台输出如下结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">just before subscribe</span><br><span class="line">got value <span class="number">1</span></span><br><span class="line">got value <span class="number">2</span></span><br><span class="line">got value <span class="number">3</span></span><br><span class="line">just after subscribe</span><br><span class="line">got value <span class="number">4</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="拉取-Pull-V-S-推送-Push"><a href="#拉取-Pull-V-S-推送-Push" class="headerlink" title="拉取(Pull) V.S. 推送(Push)"></a>拉取(Pull) V.S. 推送(Push)</h2><p><em>拉取</em>和<em>推送</em>是数据<em>生产者</em>和数据<em>消费者</em>之间通信的两种不同机制。</p>
<p><strong>何为拉取？</strong> 在拉取系统中，总是由消费者决定何时从生产者那里获得数据。生产者对数据传递给消费者的时间毫无感知（<em>被动的生产者，主动的消费者</em>）。</p>
<p>JavaScript函数是典型的拉取系统：函数是数据的生产者，对函数进行调用的代码（消费者）从函数调用后的返回值中拉取<em>单值</em>进行消费。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数是数据的生产者</span></span><br><span class="line"><span class="keyword">let</span> getLuckyNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* let代码段是数据的消费者，</span></span><br><span class="line"><span class="comment"> * getLuckyNumber对调用时间毫无感知。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> luckNumber = getLuckyNumber();</span><br></pre></td></tr></table></figure>
<p>ES2015 引入了的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">生成器函数 | 遍历器</a> (<code>function*</code>)同样是基于拉取的系统： 调用 <code>iterator.next()</code>的代码段是消费者，它可以从生成器函数中拉取多个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getLessThanTen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; <span class="number">11</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">let</span> iterator = getLessThanTen();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">iterator.next(); <span class="comment">// Object &#123;value: 0, done: false&#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// Object &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>MagicQ</th>
<th>生产者</th>
<th>消费者</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>拉取</strong></td>
<td><strong>被动:</strong> 在被请求时产生数据</td>
<td><strong>主动:</strong> 决定何时请求数据</td>
</tr>
<tr>
<td><strong>推送</strong></td>
<td><strong>主动:</strong> 控制数据的产生逻辑</td>
<td><strong>被动:</strong> 获得数据后进行响应</td>
</tr>
</tbody>
</table>
<p><strong>何为推送？</strong> 在推送系统中生产者决定何时向消费者传递数据，消费者对何时收到数据毫无感知（被动的消费者）。</p>
<p>现代JavaScript中<strong>Promise</strong>是典型的推送系统。作为数据生产者的Promise通过<code>resolve()</code>向数据消费者——回调函数传递数据：与函数不同，Promise决定向回调函数推送值的时间。</p>
<p>RxJS在 JavaScript 中引入了Observable(可观察对象)这个新的推送系统。Observable是多数据值的生产者，向Observer(被动的消费者)推送数据。</p>
<ul>
<li><strong>函数</strong> 调用后同步计算并返回单一值</li>
<li><strong>生成器函数 | 遍历器 </strong>遍历过程中同步计算并返回0个到无穷多个值</li>
<li><strong>Promise</strong> 异步执行中返回或者不返回单一值</li>
<li><strong>Observable</strong> 同步或者异步计算并返回0个到无穷多个值</li>
</ul>
<h2 id="Observable-是函数概念的拓展"><a href="#Observable-是函数概念的拓展" class="headerlink" title="Observable 是函数概念的拓展"></a>Observable 是函数概念的拓展</h2><p>Observable既不像EventEmitter，也不像是Promise。Observable 中的 Subject 进行多路推送时与 EventEmitter <strong>行为上</strong>有些类似，但是实际上Observable与EventEmitter并不相同。</p>
<p>Observable 更像是一个不需要传入参数的函数，它拓展了函数的概念使得它可以返回多个值。</p>
<p>看看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = foo.call(); <span class="comment">// same as foo()</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">var</span> y = foo.call(); <span class="comment">// same as foo()</span></span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br></pre></td></tr></table></figure>
<p>输出结果如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>通过Observable可以实现同样的行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  observer.next(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出结果相同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>不论Observable还是函数都是在运行时进行求值计算的。如果不调用函数，<code>console.log(&#39;Hello&#39;)</code>就不会执行；如果如果不<code>subscribe</code>（订阅）Observable，<code>console.log(&#39;Hello&#39;)</code>也不会执行。此外，<strong>调用</strong>或者<strong>订阅</strong>都是独立的：两次调用产生两个独立的作用域，两次订阅同样会产生两个独立的作用域。EventEmitter总是在同一个作用域中，发射前也不会在意自己是否已经被订阅；Observable不会被共享而产生副作用，并且总是在被订阅时才执行。</p>
<p>订阅Observable与调用函数类似。</p>
<p>一些人认为Observable总是是异步的，这个观点并不正确，如果在控制台log函数中调用函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.call());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure>
<p>显然可以看到以下输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"before"</span></span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="string">"after"</span></span><br></pre></td></tr></table></figure>
<p>Observable的行为完全一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"before"</span></span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="string">"after"</span></span><br></pre></td></tr></table></figure>
<p>订阅 <code>foo</code>完全是同步的，与函数的调用一样。</p>
<p>Observable可以异步或者同步地产生数据。</p>
<p>那Observable 与函数的不同之处在哪里？ <strong>Observable可以在一个时间过程中‘返回’多个值</strong>，而函数却不能。在函数中你不可以这么做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>; <span class="comment">// 这个语句永远不会被执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然函数只能有一个返回值，但是在Observable中你完全可以这么做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  observer.next(<span class="number">42</span>);</span><br><span class="line">  observer.next(<span class="number">100</span>); <span class="comment">// 返回另一个值</span></span><br><span class="line">  observer.next(<span class="number">200</span>); <span class="comment">// 返回另一个值</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"before"</span></span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="string">"after"</span></span><br></pre></td></tr></table></figure>
<p>你甚至可以异步地返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  observer.next(<span class="number">42</span>);</span><br><span class="line">  observer.next(<span class="number">100</span>);</span><br><span class="line">  observer.next(<span class="number">200</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(<span class="number">300</span>); <span class="comment">// happens asynchronously</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"before"</span></span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="string">"after"</span></span><br><span class="line"><span class="number">300</span></span><br></pre></td></tr></table></figure>
<p>结论：</p>
<ul>
<li><code>func.call()</code> 意味着“同步地给我一个值”</li>
<li><code>observable.subscribe()</code> 意味着“不管是同步或者异步，给我一些值”</li>
</ul>
<h2 id="Observable-剖析"><a href="#Observable-剖析" class="headerlink" title="Observable 剖析"></a>Observable 剖析</h2><p>通过使用 <code>Rx.Observable.create</code> 或者是<em>创建操作符</em>，<strong>创建</strong>一个Observable； Observable 被 Observer（观察者） <strong>订阅</strong>； 在<strong>执行</strong>时 向观察者发送<code>next</code> / <code>error</code> / <code>complete</code> 通知；同时执行过程可以被 <strong>终止</strong>。<br>Observable 类型的实例具备了以上四个方面的特性，与其他类型如：Observer 和 Subscription 紧密相关。</p>
<p>我们重点关注以下四个方面：</p>
<ul>
<li><strong>创建</strong></li>
<li><strong>订阅</strong></li>
<li><strong>执行</strong></li>
<li><strong>终止</strong></li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><code>Rx.Observable.create</code> 是 <code>Observable</code> 构造函数的别名，接受一个参数： <code>subscribe</code>函数。</p>
<p>以下例子会创建一个Observable，每一秒钟向其订阅者发射一个<code>&#39;hi&#39;</code> 字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable.create(<span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(<span class="string">'hi'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>除了使用<code>create</code>创建Observable，我们通常还使用<a href="">创建操作符</a>, 如 <code>of</code>，<code>from</code>， <code>interval</code>, 等来创建Observable。</p>
<p>上面例子中，<code>subscribe</code>函数是定义Observable最重要的部分。我们接下来了解订阅的含义。</p>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>上面例子中的<code>observable</code> 可以以如下方式 <em>订阅</em> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure>
<p><code>observable.subscribe</code> 和 <code>Observable.create(function subscribe(observer) {...})</code>中的<code>subscribe</code> 同名并非巧合。虽然在Rx中它们不是同一个对象，但是在工程中，我们可以在概念上视两者为等价物。</p>
<p>调用<code>subscribe</code>的观察者并不会共享同一个Observable。观察者调用<code>observable.subscribe</code> 时，<code>Observable.create(function subscribe(observer) {...})</code>中的<code>subscribe</code>会在调用它的观察者作用域中执行。每一次<code>observable.subscribe</code>的调用，都是彼此独立的。</p>
<p>订阅Observable如同调用函数，需要提供相应的回调方法。</p>
<p>订阅机制与处理事件的<code>addEventListener</code> / <code>removeEventListener</code>API完全不同。通过<code>observable.subscribe</code>，观察者并不需要在Observable中进行注册，Observable也不需要维护订阅者的列表。</p>
<p>订阅后便进入了Observable的执行阶段，在执行阶段值和事件将会被传递给观察者供其消费。</p>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>只有在被订阅之后Observable才会执行，执行的逻辑在<code>Observable.create(function subscribe(observer) {...})</code>中描述，执行后将会在特定时间段内，同步或者异步地成产多个数据值。</p>
<p>Observable在执行过程中，可以推送三种类型的值：</p>
<ul>
<li>“Next” 通知： 实际产生的数据，包括数字、字符串、对象等</li>
<li>“Error” 通知：一个JavaScript错误或者异常</li>
<li>“Complete” 通知：一个不带有值的事件</li>
</ul>
<p>“Next” 通知是最重要和常用的类型：表示事件传递给观察者的数据。错误和完成通知仅会在执行阶段推送其一，并不会同时推送错误和完成通知。</p>
<p>通过所谓的“Observable语法”或者“契约”可以最好地表达这个规则，“Observable语法”借助于正则表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next*(error|complete)?</span><br></pre></td></tr></table></figure>
<p>在Observable的执行过程中，0个或者多个“Next”通知会被推送。在错误或者完成通知被推送后，Observable不会再推送任何其他通知。</p>
<p>下面代码展示了Observable 在执行过程中推送3个“Next” 通知然后结束：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable.create(<span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  observer.next(<span class="number">1</span>);</span><br><span class="line">  observer.next(<span class="number">2</span>);</span><br><span class="line">  observer.next(<span class="number">3</span>);</span><br><span class="line">  observer.complete();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Observable 严格遵守 Observable 契约，后面值为<code>4</code>的“Next” 通知永远不会被推送：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable.create(<span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  observer.next(<span class="number">1</span>);</span><br><span class="line">  observer.next(<span class="number">2</span>);</span><br><span class="line">  observer.next(<span class="number">3</span>);</span><br><span class="line">  observer.complete();</span><br><span class="line">  observer.next(<span class="number">4</span>); <span class="comment">// 由于违法契约，4不会被推送</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用<code>try</code>/<code>catch</code>块包裹 <code>subscribe</code> 代码是一个很赞的想法，如果捕获了异常，可以推送错误通知：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable.create(<span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    observer.next(<span class="number">1</span>);</span><br><span class="line">    observer.next(<span class="number">2</span>);</span><br><span class="line">    observer.next(<span class="number">3</span>);</span><br><span class="line">    observer.complete();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    observer.error(err); <span class="comment">// 捕获异常后推送错误通知</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>Observable的执行可能是无限的，作为观察者需要主动中断执行：我们需要特定的API去终止执行过程。因为特定的观察者都有特定的执行过程，一旦观察者获得想要的数据后就需要终止执行过程以免带来计算时对内存资源的浪费。</p>
<p>在<code>observable.subscribe</code>被调用时，观察者会与其执行作用域绑定，同时返回一个<code>Subscription</code>类型的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subscription = observable.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure>
<p>Subscription对象表示执行过程，通过极简的API，你可以终止执行过程。详情请阅读<a href=""><code>Subscription</code> 相关文档</a>。通过调用<code>subscription.unsubscribe()</code> 你可以终止执行过程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable.from([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]);</span><br><span class="line"><span class="keyword">var</span> subscription = observable.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br><span class="line"><span class="comment">// Later:</span></span><br><span class="line">subscription.unsubscribe();</span><br></pre></td></tr></table></figure>
<p>在Observable被订阅后，代表执行过程的Subscription 对象将被返回。对其调用<code>unsubscribe()</code>就可以终止执行。</p>
<p>每一个Observable都需要在 <code>create()</code>的创建过程中定义终止的逻辑。在<code>function subscribe()</code>中返回自定义的<code>unsubscribe</code>就可以实现。</p>
<p>下面的例子说明了如何在终止后释放<code>setInterval</code>的句柄：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable.create(<span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得定时函数的句柄</span></span><br><span class="line">  <span class="keyword">var</span> intervalID = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(<span class="string">'hi'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 提供终止方法释放定时函数的句柄</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearInterval(intervalID);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>类似于<code>observable.subscribe</code> 和 <code>Observable.create(function subscribe() {...})</code>的关系，我们在<code>subscribe</code>中返回的 <code>unsubscribe</code> 也与<code>subscription.unsubscribe</code>在概念上等价。事实上，如果我们除去Rx的包装，纯粹的JavaScript代码简单清晰：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> intervalID = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(<span class="string">'hi'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearInterval(intervalID);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> unsubscribe = subscribe(&#123;<span class="attr">next</span>: <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(x)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段时间后:</span></span><br><span class="line">unsubscribe(); <span class="comment">// 终止</span></span><br></pre></td></tr></table></figure>
<p>使用Observable、 Observer 和 Subscription这些概念的原因是，我们可以在Observable 契约之下安全、兼容地调用操作符。</p>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2020/01/04/rxjs-observable/" class="article-date">
  <time datetime="2020-01-04T00:24:44.000Z" itemprop="datePublished">2020-01-04</time>
</a>

        </li>
        
        
        <hr>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2020/01/04/rxjs-subject/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          rxjs之Subject
        
      </div>
    </a>
  
  
    <a href="/2020/01/03/angular2-start/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">angular2-环境搭建</div>
    </a>
  
</nav>


  
</article>




      </div>
      
    <footer id="footer" class="post-footer footer">
      <hr>
      <div id="footerContent" class="footer-content">
        <p>闲步山雨后,静待晚林风 Post</p>


      </div>
    </footer>

      

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
