<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>rxjs入门 | Ace&#39;pages</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="简介RxJS is a library for composing asynchronous and event-based programs by using observable sequences. It provides one core type, the Observable, satellite types (Observer, Schedulers, Subjects) and o">
<meta property="og:type" content="article">
<meta property="og:title" content="rxjs入门">
<meta property="og:url" content="http://hujao.com/2020/01/02/rxjs-introduction/index.html">
<meta property="og:site_name" content="Ace&#39;pages">
<meta property="og:description" content="简介RxJS is a library for composing asynchronous and event-based programs by using observable sequences. It provides one core type, the Observable, satellite types (Observer, Schedulers, Subjects) and o">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://hujao.com/2020/01/02/rxjs-introduction/1.jpeg">
<meta property="og:image" content="http://hujao.com/2020/01/02/rxjs-introduction/2.jpeg">
<meta property="og:image" content="http://hujao.com/2020/01/02/rxjs-introduction/3.jpeg">
<meta property="og:image" content="http://hujao.com/2020/01/02/rxjs-introduction/4.jpeg">
<meta property="og:image" content="http://hujao.com/2020/01/02/rxjs-introduction/5.jpeg">
<meta property="og:image" content="http://hujao.com/2020/01/02/rxjs-introduction/6.jpeg">
<meta property="og:image" content="http://hujao.com/2020/01/02/rxjs-introduction/7.jpeg">
<meta property="og:image" content="http://hujao.com/2020/01/02/rxjs-introduction/8.jpeg">
<meta property="og:image" content="http://hujao.com/2020/01/02/rxjs-introduction/9.jpeg">
<meta property="og:updated_time" content="2020-01-03T02:48:22.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="rxjs入门">
<meta name="twitter:description" content="简介RxJS is a library for composing asynchronous and event-based programs by using observable sequences. It provides one core type, the Observable, satellite types (Observer, Schedulers, Subjects) and o">
<meta name="twitter:image" content="http://hujao.com/2020/01/02/rxjs-introduction/1.jpeg">
  
    <link rel="alternate" href="/atom.xml" title="Ace&#39;pages" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
</head>
</html>
  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-rxjs-introduction" class="article article-type-post" itemscope="" itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/tags/docker">Docker</a>
    
      <a class="main-nav-link" href="/tags/springboot">SpringBoot</a>
    
      <a class="main-nav-link" href="/tags/elasticsearch">ElasticSearch</a>
    
      <a class="main-nav-link" href="/tags/test">Test</a>
    
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
    
  </nav>
</header>

  <hr>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      rxjs入门
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>RxJS is a library for composing asynchronous and event-based programs by using observable sequences. It provides one core type, the Observable, satellite types (Observer, Schedulers, Subjects) and operators inspired by Array#extras (map, filter, reduce, every, etc) to allow handling asynchronous events as collections.</p>
<p>ReactiveX combines the Observer pattern with the Iterator pattern and functional programming with collections to fill the need for an ideal way of managing sequences of events.</p>
<p>The essential concepts in RxJS which solve async event management are:</p>
<ul>
<li><strong>Observable:</strong> represents the idea of an invokable collection of future values or events.</li>
<li><strong>Observer:</strong> is a collection of callbacks that knows how to listen to values delivered by the Observable.</li>
<li><strong>Subscription:</strong> represents the execution of an Observable, is primarily useful for cancelling the execution.</li>
<li><strong>Operators:</strong> are pure functions that enable a functional programming style of dealing with collections with operations like <code>map</code>, <code>filter</code>, <code>concat</code>, <code>flatMap</code>, etc.</li>
<li><strong>Subject:</strong> is the equivalent to an EventEmitter, and the only way of multicasting a value or event to multiple Observers.</li>
<li><strong>Schedulers:</strong> are centralized dispatchers to control concurrency, allowing us to coordinate when computation happens on e.g. <code>setTimeout</code> or <code>requestAnimationFrame</code> or others.</li>
</ul>
<h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/rxjs/6.0.0-alpha.3/Rx.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'myBtn'</span>&gt;</span>addEventListener<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'demo'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// document.getElementById("myBtn").addEventListener("click", function () &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   document.getElementById("demo").innerHTML = "button clicked !!";</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;);</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span></span><br><span class="line"><span class="javascript">    Rx.Observable.fromEvent(button, <span class="string">'click'</span>).subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Clicked!'</span>));</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>异步与回调地狱</strong>  ajax—-&gt;另一个ajax   多重回调嵌套</p>
<p><strong>Promise</strong> 承诺解决回调嵌套问题 但立即执行,无法取消</p>
<p><strong>Observable</strong> 可观察对象 ,消息队列MQ</p>
<p>Observable 就像个传送带。这个传送带不断运行，围绕这个传送带建立了一条生产线，包括一系列工序，不同的工序承担单一而确定的职责。每个工位上有一个工人。</p>
<p>整个传送带的起点是原料箱，原料箱中的原料不断被放到传送带上。工人只需要待在自己的工位上，对面前的原料进行加工，然后放回传送带上或放到另一条传送带上即可。</p>
<p><strong>FRP</strong> 函数响应式编程</p>
<p><strong>宝石图</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  clickStream: ---c----c--c----c------c---&gt;</span><br><span class="line">               vvvvv map(c becomes <span class="number">1</span>) vvvvv</span><br><span class="line">               --<span class="number">-1</span>---<span class="number">-1</span>-<span class="number">-1</span>---<span class="number">-1</span>-----<span class="number">-1</span>---&gt;</span><br><span class="line">               vvvvvvvvv  scan(+) vvvvvvvvv</span><br><span class="line">counterStream: --<span class="number">-1</span>---<span class="number">-2</span>-<span class="number">-3</span>---<span class="number">-4</span>-----<span class="number">-5</span>---&gt;</span><br></pre></td></tr></table></figure>
<p>中间的带箭头的线就像传送带，用来表示数据序列，这个数据序列被称为“流”。上方的流叫做输入流，下方的流叫做输出流。输入流可能有多个，但是输出流只会有一个（不过，流中的每个数据项也可以是别的流）。</p>
<p>数据序列上的每个圆圈表示一个数据项，圆圈的位置表示数据出现的先后顺序，但是一般不会表示精确的时间比例，比如在一毫秒内接连出现的两个数据之间仍然会有较大的距离。只有少数涉及到时间的操作，其宝石图才会表现出精确的时间比例。</p>
<p>圆圈的最后，通常会有一条竖线或者一个叉号。竖线表示这个流正常终止了，也就是说不会再有更多的数据提供出来了。而叉号表示这个流抛出错误导致异常中止了。还有一种流，既没有竖线也没有叉号，这种叫做无尽流，比如一个由所有自然数组成的流就不会主动终止。但是要注意，无尽流仍然是可以处理的，因为需要多少项是由消费者决定的。你可以把这个“智能”传送带理解为由下一个工位“叫号”的，没“叫号”下一项数据就不会过来。</p>
<p>中间的大方框表示一个操作，也就是 operator —— 一个函数，比如这个图中的操作就是把输入流中的条目乘以十后放入输出流中。</p>
<p>看懂了宝石图，就能很形象的理解各种操作符了。</p>
<p><strong>典型写法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; interval, <span class="keyword">of</span>, throwError &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; filter, map &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).pipe(   <span class="comment">// of创建器 构造输入流</span></span><br><span class="line">	filter(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">1</span>),<span class="comment">// filter操作符 对输入流做过滤 按条件 输出奇数 1,3</span></span><br><span class="line">	map(<span class="function"><span class="params">item</span> =&gt;</span> item = item * <span class="number">2</span>)<span class="comment">// map操作符 对输入流做映射操作  输出乘2 2,6</span></span><br><span class="line">).subscribe(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item));</span><br></pre></td></tr></table></figure>
<p>其中 of 称为创建器（creator），用来创建流，它返回一个 Observable 类型的对象，filter 和 map 称为操作符（operator），用来对条目进行处理。这些操作符被当作 Observable 对象的 pipe 方法的参数传进去。诚然，这个写法略显怪异，不过这主要是被 js 的设计缺陷所迫，它已经是目前 js 体系下多种解决方案中相对好看的一种了。</p>
<p>Observable 对象的 subscribe 方法表示消费者要订阅这个流，当流中出现数据时，传给 subscribe 方法的回调函数就会被调用，并且把这个数据传进去。这个回调函数可能被调用很多次，取决于这个流中有多少条数据。</p>
<p>注意，Observable 必须被 subscribe 之后才会开始生产数据。如果没人 subscribe 它，那就什么都不会做。</p>
<p><strong>简单创建器</strong></p>
<p><strong>of - 单一值转为流</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">of(1,2,3)</span><br></pre></td></tr></table></figure>
<p><strong>from - 数组转为流</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from([10,20,30])</span><br></pre></td></tr></table></figure>
<p><strong>range - 范围转为流</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(1,10)</span><br></pre></td></tr></table></figure>
<p><strong>fromPromise - Promise 转为流</strong></p>
<p>这个 Promise 就开始执行了，你<strong>没有机会防止它被执行</strong>。</p>
<p>如果你需要这个 Promise 被消费时才执行，那就要改用接下来要讲的 <code>defer</code> 创建器</p>
<p><strong>defer - 惰性创建流</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defer(()=&gt;Observable.of(a,b,c))</span><br></pre></td></tr></table></figure>
<p>它的参数是一个用来生产流的工厂函数。也就是说，当消费方需要流（注意不是需要流中的值）的时候，就会调用这个函数，创建一个流，并从这个流中进行消费（取数据）。</p>
<p>因此，当我们定义 defer 的时候，实际上还不存在一个真正的流，只是给出了创建这个流的方法，所以叫惰性创建流。</p>
<p><strong>timer - 定时器流</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer(3000,1000)</span><br></pre></td></tr></table></figure>
<p>第一个是首次等待时间，第二个是重复间隔时间,实际上是个无尽流 —— 没有终止线</p>
<p><strong>interval - 定时器流</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interval(1000)</span><br></pre></td></tr></table></figure>
<p>相当于timer(1000,1000)</p>
<h5 id="Subject-主题对象"><a href="#Subject-主题对象" class="headerlink" title="Subject - 主题对象"></a>Subject - 主题对象</h5><p>它和创建器不同，创建器是供直接调用的函数，而 Subject 则是一个实现了 Observable 接口的类。也就是说，你要先把它 <code>new</code> 出来（假设实例叫 <code>subject</code>），然后你就可以通过程序控制的方式往流里手动放数据了。它的典型用法是用来管理事件，比如当用户点击了某个按钮时，你希望发出一个事件，那么就可以调用 <code>subject.next(someValue)</code> 来把事件内容放进流中。</p>
<p>当你希望手动控制往这个流中放数据的时机时，这种特性非常有用。</p>
<p>当然，Subject 其实并没有这么简单，用法也很多。</p>
<h4 id="合并创建器"><a href="#合并创建器" class="headerlink" title="合并创建器"></a>合并创建器</h4><p>我们不但可以直接创建流，还可以对多个现有的流进行不同形式的合并，创建一个新的流。常见的合并方式有三种：并联、串联、拉链。</p>
<p><strong>merge - 并联</strong></p>
<p><img src="/2020/01/02/rxjs-introduction/1.jpeg" alt="1"></p>
<p>从图上我们可以看到两个流中的内容被合并到了一个流中。只要任何一个流中出现了值就会立刻被输出，哪怕其中一个流是完全空的也不影响结果 —— 等同于原始流。</p>
<p>这种工作方式非常像电路中的并联行为，因此我称其为并联创建器。</p>
<p>这样，<strong>无论哪个流中出现了数据，都会进行刷新</strong>。</p>
<p><strong>concat - 串联</strong></p>
<p><img src="/2020/01/02/rxjs-introduction/2.jpeg" alt="2"></p>
<p>从图中我们可以看到两个流中的内容被按照顺序放进了输出流中。前面的流尚未结束时（注意竖线），后面的流就会一直等待。</p>
<p><strong>zip - 拉链</strong></p>
<p><img src="/2020/01/02/rxjs-introduction/3.jpeg" alt="3"></p>
<p>zip 的直译就是拉链，事实上，有些压缩软件的图标就是一个带拉链的钥匙包。拉链的特点是两边各有一个“齿”，两者会啮合在一起。这里的 zip 操作也是如此。</p>
<p>从图上我们可以看到，两个输入流中分别出现了一些数据，当仅仅输入流 A 中出现了数据时，输出流中什么都没有，因为它还在等另一个“齿”。当输出流 B 中出现了数据时，两个“齿”都凑齐了，于是对这两个齿执行中间定义的运算（取 A 的形状，B 的颜色，并合成为输出数据）。</p>
<p>可以看到，当任何一个流先行结束之后，整个输出流也就结束了。</p>
<p>拉链创建器适用的场景要少一些，通常用于合并两个数据有对应关系的数据源。比如一个流中是姓名，另一个流中是成绩，还有一个流中是年龄，如果这三个流中的每个条目都有精确的对应关系，那么就可以通过 zip 把它们合并成一个由表示学生成绩的对象组成的流。</p>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><p>RxJS 有很多操作符，事实上比创建器还要多一些，但是我们并不需要一一讲解，因为它们中的很大一部分都是函数式编程中的标配，比如 map、reduce、filter 等。有 Java 8 / scala / kotlin 等基础的后端或者用过 underscore/lodash 的前端都可以非常容易地理解它们。</p>
<p>本文重点讲解一些传统方式下没有的或不常用的：</p>
<p><strong>retry - 失败时重试</strong></p>
<p><img src="/2020/01/02/rxjs-introduction/4.jpeg" alt="4"></p>
<p>有些错误是可以通过重试进行恢复的，比如临时性的网络丢包。甚至一些流程的设计还会故意借助重试机制，比如当你发起请求时，如果后端发现你没有登录过，就会给你一个 401 错误，然后你可以完成登录并重新开始整个流程。</p>
<p>retry 操作符就是负责在失败时自动发起重试的，它可以接受一个参数，用来指定最大重试次数。</p>
<p>这里我为什么一直在强调失败时重试呢？因为还有一个操作符负责成功时重试。</p>
<p><strong>repeat - 成功时重试</strong></p>
<p><img src="/2020/01/02/rxjs-introduction/5.jpeg" alt="5"></p>
<p>除了重复的条件之外，repeat 的行为几乎和 retry 一模一样。</p>
<p>repeat 很少会单独用，一般会组合上 delay 操作，以提供暂停时间，否则就容易 DoS 了服务器。</p>
<p><strong>delay - 延迟</strong></p>
<p><img src="/2020/01/02/rxjs-introduction/6.jpeg" alt="6"></p>
<p>这才是真正的 setTimeout 的等价操作。它接受一个毫秒数（图中是 20 毫秒），每当它从输入流中读取一个数据之后，会先等待 20 毫秒，然后再放到输出流中。</p>
<p>可以看到，输入流和输出流内容是完全一样的，只是时机上，输出流中的每个条目都恰好比输入流晚 20 毫秒出现。</p>
<p><strong>toArray - 收集为数组</strong></p>
<p><img src="/2020/01/02/rxjs-introduction/7.jpeg" alt="7"></p>
<p>事实上，你几乎可以把它看做是 from 的逆运算。 from 把数组打散了逐个放进流中，而 toArray 恰好相反，把流中的内容收集到一个数组中 —— 直到这个流结束。</p>
<p>这个操作符几乎总是放在最后一步，因为 RxJS 的各种 operator 本身就可以对流中的数据进行很多类似数组的操作，比如查找最小值、最大值、过滤等。所以通常会先使用各种 operator 对数据流进行处理，等到要脱离 RxJS 的体系时，再转换成数组传出去。</p>
<p><strong>debounceTime - 防抖</strong></p>
<p><img src="/2020/01/02/rxjs-introduction/8.jpeg" alt="8"></p>
<p>在 underscore/lodash 中这是常用函数。 所谓防抖其实就是“等它平静下来”。比如预输入（type ahead）功能，当用户正在快速打字的时候，你没必要立刻去查服务器，否则可能直接让服务器挂了，而应该等用户稍作停顿（平静下来）时再发起查询。</p>
<p>debounceTime 就是这样，你传入一个最小平静时间，在这个时间窗口内连续过来的数据一概被忽略，一旦平静时间超过它，就会往把接收到的下一条数据放到流中。这样消费者就只能看到平静时间超时之后发来的最后一条数据。</p>
<p><strong>switchMap - 切换成另一个流</strong></p>
<p><img src="/2020/01/02/rxjs-introduction/9.jpeg" alt="9"></p>
<p>这可能是相对较难理解的一个 operator。</p>
<p>有时候，我们会希望根据一个立即数发起一个远程查询，并且把这个异步取回的结果放进流中。比如，流中是一些学生的 id，每过来一个 id，你要发起一个 Ajax 请求来根据这个 id 获取这个学生的详情，并且把详情放进输出流中。</p>
<p>注意，这是一个异步操作，所以你没法用普通的 map 来实现，否则映射出来的结果就会是一个个 Observable 对象。</p>
<p>switchMap 就是用来解决这个问题的。它在回调函数中接受从输入流中传来的数据，并转换成一个新的 Observable 对象（新的流，每个流中包括三个值，每个值都等于输入值的十倍），switchMap 会订阅这个 Observable 对象，并把它的值放入输出流中。注意图中竖线的位置 —— 只有当所有新的流都结束时，输出流才会结束。</p>
<p>不知道你有没有注意到这里一个很重要的细节。30 只生成了两个值，而不是我们所预期的三个。这是因为当输入流中的 5 到来时，会切换到以 5 为参数构建出的这个新流（S5），而这时候基于 3 构建的那个流（S3）尚未结束。虽然如此，但是已经没人再订阅 S3 了，因为同一时刻 switchMap 只能订阅一个流。所以，已经没人会再朝着 S3 “叫号”了，它已经被释放了。</p>
<h4 id="规律：operator-打包学"><a href="#规律：operator-打包学" class="headerlink" title="规律：operator 打包学"></a>规律：operator 打包学</h4><p>当你掌握了一些基本操作符之后，就可以让自己的操作符知识翻倍了。</p>
<p>这是因为 RxJS 中的很多操作符都遵循着同样的命名模式。比如：</p>
<p><strong>xxxWhen - 满足条件时 xxx</strong></p>
<p>它接受一个 Observable 型参数作为条件流，一旦这个条件流中出现任意数据，则进行 xxx 操作。</p>
<p>如 <code>retryWhen(notifier$)</code>，其中的 <code>notifier$</code> 就是一个条件流。当输入流出现异常时，就会开始等待 <code>notifier$</code> 流中出现数据，一旦出现了任何数据（不管是什么值），就会开始执行重试逻辑。</p>
<p><strong>xxxCount - 拿到 n 个数据项时 xxx</strong></p>
<p>它接受一个数字型参数作为阈值，一旦从输入流中取到了 n 个数据，则进行 xxx 操作。</p>
<p>如 <code>bufferCount(3)</code> 表示每拿到 3 个数据就进行一次 <code>buffer</code> 操作。</p>
<p>这个操作可以看做是 <code>xxxWhen</code> 的语法糖。</p>
<p><strong>xxxTime - 超时后 xxx</strong></p>
<p>它接受一个超时时间作为参数，从输入流中取数据，一旦到达超时时间，则执行 xxx 操作。</p>
<p>比如前面讲过的 <code>debounceTime</code> 其实遵循的就是这种模式。</p>
<p>这个操作可以看做 <code>xxxWhen</code> 的语法糖。</p>
<p><strong>xxxTo - 用立即量代替 Lambda 表达式</strong></p>
<p>它接受一个立即量作为参数，相当于 <code>xxx(()=&amp;amp;gt;value))</code>。</p>
<p>比如 <code>mapTo(&#39;a&#39;)</code> 其实是 <code>map(()=&amp;amp;gt;&#39;a&#39;)</code> 的语法糖，也就是说无论输入流中给出的值是什么，我往输出流中放入的都是这个固定的值。</p>
<h4 id="坑与最佳实践"><a href="#坑与最佳实践" class="headerlink" title="坑与最佳实践"></a>坑与最佳实践</h4><p><strong>取消订阅</strong></p>
<p>subscribe 之后，你的回调函数就被别人引用了，因此如果不撤销对这个回调函数的引用，那么与它相关的内存就永远不会释放，同时，它仍然会在流中有数据过来时被调用，可能会导致奇怪的 console.log 等意外行为。</p>
<p>因此，必须找到某个时机撤销对这个回调函数的引用。但其实不一定需要那么麻烦。解除对回调函数的引用有两种时机，一种是这个流完成（complete，包括正常结束和异常结束）了，一种是订阅方主动取消。当流完成时，会自动解除全部订阅回调，而所有的有限流都是会自动完成的。只有无尽流才需要特别处理，也就是订阅方要主动取消订阅。</p>
<p>当调用 <code>Observable</code> 的 <code>subscribe</code> 方法时，会返回一个 <code>Subscription</code> 类型的引用，它实际上是一个订阅凭证。把它保存下来，等恰当的时机调用它的 <code>unsubscribe</code> 方法就可以取消订阅了。比如在 Angular 中，如果你订阅了无尽流，那么就需要把订阅凭证保存在私有变量里，并且在 <code>ngOnDestroy</code> 回调中调用它的 <code>unsubscribe</code> 方法。</p>
<p><strong>类型检查</strong></p>
<p>只要有可能，请尽量使用 TypeScript 来书写 RxJS 程序。由于大量 operator 都会改变流中的数据类型，因此如果靠人力来追踪数据类型的变化既繁琐又容易出错。TypeScript 的类型检查可以给你提供很大的帮助，既省心又安全，而且这两个都是微软家的，搭配使用，风味更佳。</p>
<p><strong>代码风格</strong></p>
<p>如同所有 FP 程序一样，ReactiveX 的代码也应该由一系列小的、单一职责的、无副作用的函数组成。虽然 JavaScript 无法像 Java 中那样对 Lambda 表达式的副作用做出编译期限制，但是仍然要遵循同样的原则，坚持无副作用和数据不变性。</p>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2020/01/02/rxjs-introduction/" class="article-date">
  <time datetime="2020-01-02T06:22:07.000Z" itemprop="datePublished">2020-01-02</time>
</a>

        </li>
        
        
        <hr>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2020/01/04/rxjs-observable/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          rxjs之Observable
        
      </div>
    </a>
  
  
    <a href="/2019/12/31/druid/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">配置druid监控页面</div>
    </a>
  
</nav>


  
</article>




      </div>
      
    <footer id="footer" class="post-footer footer">
      <hr>
      <div id="footerContent" class="footer-content">
        <p>闲步山雨后,静待晚林风 Post</p>


      </div>
    </footer>

      

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
