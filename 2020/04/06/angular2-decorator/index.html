<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>angular2-decorator | Ace&#39;pages</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="装饰器是什么 它是一个表达式 该表达式被执行后，返回一个函数 函数的入参分别为 target、name 和 descriptor 执行该函数后，可能返回 descriptor 对象，用于配置 target 对象  装饰器的分类 类装饰器 (Class decorators) 属性装饰器 (Property decorators) 方法装饰器 (Method decorators) 参数装饰器 (P">
<meta property="og:type" content="article">
<meta property="og:title" content="angular2-decorator">
<meta property="og:url" content="http://hujao.com/2020/04/06/angular2-decorator/index.html">
<meta property="og:site_name" content="Ace&#39;pages">
<meta property="og:description" content="装饰器是什么 它是一个表达式 该表达式被执行后，返回一个函数 函数的入参分别为 target、name 和 descriptor 执行该函数后，可能返回 descriptor 对象，用于配置 target 对象  装饰器的分类 类装饰器 (Class decorators) 属性装饰器 (Property decorators) 方法装饰器 (Method decorators) 参数装饰器 (P">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-04-05T18:42:36.247Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="angular2-decorator">
<meta name="twitter:description" content="装饰器是什么 它是一个表达式 该表达式被执行后，返回一个函数 函数的入参分别为 target、name 和 descriptor 执行该函数后，可能返回 descriptor 对象，用于配置 target 对象  装饰器的分类 类装饰器 (Class decorators) 属性装饰器 (Property decorators) 方法装饰器 (Method decorators) 参数装饰器 (P">
  
    <link rel="alternate" href="/atom.xml" title="Ace&#39;pages" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
</head>
</html>
  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-angular2-decorator" class="article article-type-post" itemscope="" itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/tags/docker">Docker</a>
    
      <a class="main-nav-link" href="/tags/springboot">SpringBoot</a>
    
      <a class="main-nav-link" href="/tags/elasticsearch">ElasticSearch</a>
    
      <a class="main-nav-link" href="/tags/test">Test</a>
    
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
    
  </nav>
</header>

  <hr>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      angular2-decorator
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h5 id="装饰器是什么"><a href="#装饰器是什么" class="headerlink" title="装饰器是什么"></a>装饰器是什么</h5><ul>
<li>它是一个表达式</li>
<li>该表达式被执行后，返回一个函数</li>
<li>函数的入参分别为 target、name 和 descriptor</li>
<li>执行该函数后，可能返回 descriptor 对象，用于配置 target 对象</li>
</ul>
<h5 id="装饰器的分类"><a href="#装饰器的分类" class="headerlink" title="装饰器的分类"></a>装饰器的分类</h5><ul>
<li>类装饰器 (Class decorators)</li>
<li>属性装饰器 (Property decorators)</li>
<li>方法装饰器 (Method decorators)</li>
<li>参数装饰器 (Parameter decorators)</li>
</ul>
<h5 id="TypeScript-类装饰器"><a href="#TypeScript-类装饰器" class="headerlink" title="TypeScript 类装饰器"></a>TypeScript 类装饰器</h5><p>类装饰器声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare type ClassDecorator = &lt;TFunction extends Function&gt;(target: TFunction) =&gt; TFunction | void</span><br></pre></td></tr></table></figure>
<p>类装饰器顾名思义，就是用来装饰类的。它接收一个参数：</p>
<ul>
<li>target: TFunction - 被装饰的类</li>
</ul>
<p>看完第一眼后，是不是感觉都不好了。没事，我们马上来个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Greeter(target: Function): void &#123;</span><br><span class="line">  target.prototype.greet = function (): void &#123;</span><br><span class="line">    console.log(&apos;Hello!&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Greeter</span><br><span class="line">class Greeting &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    // 内部实现</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myGreeting = new Greeting();</span><br><span class="line">myGreeting.greet(); // console output: &apos;Hello!&apos;;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们定义了 Greeter 类装饰器，同时我们使用了 <a href="https://github.com/greeter" target="_blank" rel="noopener">@greeter</a> 新的语法，来使用装饰器。</p>
<p>(备注：读者可以直接复制上面的代码，在 TypeScript Playground 中运行查看结果)。</p>
<p>有的读者可能想问，例子中总是输出 Hello! ，能自定义输出的问候语么 ？这个问题很好，答案是可以的。具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Greeter(greeting: string) &#123;</span><br><span class="line">  return function(target: Function) &#123;</span><br><span class="line">    target.prototype.greet = function(): void &#123;</span><br><span class="line">      console.log(greeting);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Greeter(&apos;您好&apos;)</span><br><span class="line">class Greeting &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    // 内部实现</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myGreeting = new Greeting();</span><br><span class="line">myGreeting.greet(); // console output: &apos;您好!&apos;;</span><br></pre></td></tr></table></figure>
<p>TypeScript 属性装饰器</p>
<p>属性装饰器声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare type PropertyDecorator = (target:Object, propertyKey: string | symbol ) =&gt; void;</span><br></pre></td></tr></table></figure>
<p>属性装饰器顾名思义，用来装饰类的属性。它接收两个参数：</p>
<ul>
<li>target: Object - 被装饰的类</li>
<li>propertyKey:string | symbol - 被装饰类的属性名</li>
</ul>
<p>趁热打铁，马上来个例子热热身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function LogChanges(target: Object, key: string) &#123;</span><br><span class="line">  var propertyValue: string = this[key];</span><br><span class="line">  if(delete this[key]) &#123;</span><br><span class="line">    Object.defineProperty(target, key, &#123;</span><br><span class="line">      get: function () &#123;</span><br><span class="line">        return propertyValue;</span><br><span class="line">      &#125;,</span><br><span class="line">      set: function(newValue) &#123;</span><br><span class="line">        propertyValue = newValue;</span><br><span class="line">        console.log(`$&#123;key&#125; is now $&#123;propertyValue&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit &#123;</span><br><span class="line">  @LogChanges</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let fruit = new Fruit();</span><br><span class="line">fruit.name = &apos;apple&apos;; // console output: &apos;name is now apple&apos;</span><br><span class="line">fruit.name = &apos;banana&apos;; // console output: &apos;name is now banana&apos;</span><br></pre></td></tr></table></figure>
<p>那么问题来了，如果用户想在属性变化的时候，自动刷新页面，而不是简单地在控制台输出消息，那要怎么办？我们能不能参照类装饰器自定义问候语的方式，来实现监测属性变化的功能。具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function LogChanges(callbackObject: any) &#123;</span><br><span class="line">  return function(target: Object, key: string): void &#123;</span><br><span class="line">    var propertyValue: string = this[key];</span><br><span class="line"> 	 if(delete this[key]) &#123;</span><br><span class="line">    	Object.defineProperty(target, key, &#123;</span><br><span class="line">          get: function () &#123;</span><br><span class="line">              return propertyValue;</span><br><span class="line">          &#125;,</span><br><span class="line">          set: function(newValue) &#123;</span><br><span class="line">              propertyValue = newValue;</span><br><span class="line">              callbackObject.onchange.call(this, propertyValue);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit &#123;</span><br><span class="line">  @LogChanges(&#123;</span><br><span class="line">    onchange: function(newValue: string): void &#123;</span><br><span class="line">      console.log(`The fruit is $&#123;newValue&#125; now`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let fruit = new Fruit();</span><br><span class="line">fruit.name = &apos;apple&apos;; // console output: &apos;The fruit is apple now&apos;</span><br><span class="line">fruit.name = &apos;banana&apos;; // console output: &apos;The fruit is banana now&apos;</span><br></pre></td></tr></table></figure>
<p>TypeScript 方法装饰器</p>
<p>方法装饰器声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare type MethodDecorator = &lt;T&gt;(target:Object, propertyKey: string | symbol, descriptor: TypePropertyDescript&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | void;</span><br></pre></td></tr></table></figure>
<p>方法装饰器顾名思义，用来装饰类的属性。它接收三个参数：</p>
<ul>
<li>target: Object - 被装饰的类</li>
<li>propertyKey: string | symbol - 方法名</li>
<li>descriptor: TypePropertyDescript - 属性描述符</li>
</ul>
<p>废话不多说，直接上例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function LogOutput(tarage: Function, key: string, descriptor: any) &#123;</span><br><span class="line">  var originalMethod = descriptor.value;</span><br><span class="line">  var newMethod = function(...args: any[]): any &#123;</span><br><span class="line">    var result: any = originalMethod.apply(this, args);</span><br><span class="line">    if(!this.loggedOutput) &#123;</span><br><span class="line">      this.loggedOutput = new Array&lt;any&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    this.loggedOutput.push(&#123;</span><br><span class="line">      method: key,</span><br><span class="line">      parameters: args,</span><br><span class="line">      output: result,</span><br><span class="line">      timestamp: new Date()</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">  descriptor.value = newMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Calculator &#123;</span><br><span class="line">  @LogOutput</span><br><span class="line">  double (num: number): number &#123;</span><br><span class="line">    return num * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let calc = new Calculator();</span><br><span class="line">calc.double(11);</span><br><span class="line">// console ouput: [&#123;method: &quot;double&quot;, output: 22, ...&#125;]</span><br><span class="line">console.log(calc.loggedOutput);</span><br></pre></td></tr></table></figure>
<p>最后我们来看一下参数装饰器：</p>
<p>TypeScript 参数装饰器</p>
<p>参数装饰器声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number ) =&gt; void</span><br></pre></td></tr></table></figure>
<p>参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：</p>
<ul>
<li>target: Object - 被装饰的类</li>
<li>propertyKey: string | symbol - 方法名</li>
<li>parameterIndex: number - 方法中参数的索引值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Log(target: Function, key: string, parameterIndex: number) &#123;</span><br><span class="line">  var functionLogged = key || target.prototype.constructor.name;</span><br><span class="line">  console.log(`The parameter in position $&#123;parameterIndex&#125; at </span><br><span class="line">        $&#123;functionLogged&#125; has been decorated`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Greeter &#123;</span><br><span class="line">  greeting: string;</span><br><span class="line">  constructor(@Log phrase: string) &#123;</span><br><span class="line">	this.greeting = phrase; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// console output: The parameter in position 0 at Greeter has</span><br><span class="line">// been decorated</span><br></pre></td></tr></table></figure>
<p>我有话说</p>
<p>1.Object.defineProperty() 方法有什么用 ？</p>
<p>Object.defineProperty 用于在一个对象上定义一个新的属性或者修改一个已存在的属性，并返回这个对象。 方法的签名：Object.defineProperty(obj, prop, descriptor) ，参数说明如下：</p>
<ul>
<li>obj 需要定义的属性对象</li>
<li>prop 需被定义或修改的属性名</li>
<li>descriptor 需被定义或修改的属性的描述符</li>
</ul>
<p>对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个拥有可写或不可写值的属性。存取描述符是由一对 getter-setter 函数功能来描述的属性。描述符必须是两种形式之一，不能同时是两者。</p>
<p>数据描述符和存取描述符均具有以下可选键值：</p>
<ul>
<li>configurable<br>当且仅当该属性的 configurable 为 true 时，该属性才能够被改变，也能够被删除。默认为 false。</li>
<li>enumerable<br>当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</li>
</ul>
<p>数据描述符同时具有以下可选键值：</p>
<ul>
<li>value<br>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</li>
<li>writable<br>当且仅当仅当该属性的writable为 true 时，该属性才能被赋值运算符改变。默认为 false。</li>
</ul>
<p>存取描述符同时具有以下可选键值：</p>
<ul>
<li>get<br>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为undefined。</li>
<li>set<br>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为undefined。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;; // 创建一个新对象</span><br><span class="line">Object.defineProperty(o, &quot;a&quot;, &#123;value : 37, writable : true, enumerable : true, 	</span><br><span class="line">  configurable : true&#125;);</span><br></pre></td></tr></table></figure>
<p>总结</p>
<p>本文主要介绍了 TypeScript 中的四种装饰器，了解装饰器的基本分类和实现原理，为我们下一篇深入 Angular 2 的 <a href="https://github.com/NgModule" target="_blank" rel="noopener">@NgModule</a>、<a href="https://github.com/component" target="_blank" rel="noopener">@component</a>、<a href="https://github.com/Injectable" target="_blank" rel="noopener">@Injectable</a> 等常用装饰器做好铺垫。</p>
<p>在 <a href="https://github.com/semlinker/angular2-ionic2/issues/9" target="_blank" rel="noopener">Angular 2 Decorators - part 1 </a>文章中，我们介绍了 TypeScript 中的四种装饰器。本文的主要目的是介绍 Angular 2 中常见的内置装饰器。Angular 2 内置装饰器分类：</p>
<ul>
<li>类装饰器<ul>
<li><a href="https://github.com/component" target="_blank" rel="noopener">@component</a>、<a href="https://github.com/NgModule" target="_blank" rel="noopener">@NgModule</a>、<a href="https://github.com/pipe" target="_blank" rel="noopener">@pipe</a>、<a href="https://github.com/Injectable" target="_blank" rel="noopener">@Injectable</a></li>
</ul>
</li>
<li>属性装饰器<ul>
<li><a href="https://github.com/input" target="_blank" rel="noopener">@input</a>、<a href="https://github.com/output" target="_blank" rel="noopener">@output</a>、<a href="https://github.com/ContentChild" target="_blank" rel="noopener">@ContentChild</a>、<a href="https://github.com/ContentChildren" target="_blank" rel="noopener">@ContentChildren</a>、<a href="https://github.com/ViewChild" target="_blank" rel="noopener">@ViewChild</a>、<a href="https://github.com/ViewChildren" target="_blank" rel="noopener">@ViewChildren</a></li>
</ul>
</li>
<li>方法装饰器<ul>
<li><a href="https://github.com/HostListener" target="_blank" rel="noopener">@HostListener</a></li>
</ul>
</li>
<li>参数装饰器<ul>
<li><a href="https://github.com/Inject" target="_blank" rel="noopener">@Inject</a>、<a href="https://github.com/optional" target="_blank" rel="noopener">@optional</a>、<a href="https://github.com/self" target="_blank" rel="noopener">@self</a>、<a href="https://github.com/SkipSelf" target="_blank" rel="noopener">@SkipSelf</a>、<a href="https://github.com/host" target="_blank" rel="noopener">@host</a></li>
</ul>
</li>
</ul>
<p>Angular 2 类装饰器示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NgModule, Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;example-component&apos;,</span><br><span class="line">  template: &apos;&lt;div&gt;Woo a component!&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class ExampleComponent &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(&apos;Hey I am a component!&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Angular 2 属性装饰器示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Input &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;example-component&apos;,</span><br><span class="line">  template: &apos;&lt;div&gt;Woo a component!&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class ExampleComponent &#123;</span><br><span class="line">  @Input()</span><br><span class="line">  exampleProperty: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Angular 2 方法装饰器示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, HostListener &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;example-component&apos;,</span><br><span class="line">  template: &apos;&lt;div&gt;Woo a component!&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class ExampleComponent &#123;</span><br><span class="line">  @HostListener(&apos;click&apos;, [&apos;$event&apos;])</span><br><span class="line">  onHostClick(event: Event) &#123;</span><br><span class="line">    // clicked, `event` available</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Angular 2 参数装饰器示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Inject &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; MyService &#125; from &apos;./my-service&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;example-component&apos;,</span><br><span class="line">  template: &apos;&lt;div&gt;Woo a component!&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class ExampleComponent &#123;</span><br><span class="line">  constructor(@Inject(MyService) myService) &#123; // 与myService: MyService等价</span><br><span class="line">    console.log(myService);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们就着重分析一下最常用的类装饰器 <a href="https://github.com/component" target="_blank" rel="noopener">@component</a> ，其它的装饰器读者有兴趣的话，可以参考 Component 的分析思路自行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;my-app&apos;, </span><br><span class="line">  template: `&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;`, </span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent  &#123;</span><br><span class="line">  name = &apos;Angular&apos;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先从最简单的例子入手，我们都知道采用 TypeScript 开发，为了保证兼容性最终都会转换成标准的 ES 5代码。上面的例子转成如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">define([&quot;require&quot;, &quot;exports&quot;, &quot;@angular/core&quot;], function (require, exports, core_1) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">  </span><br><span class="line">    Object.defineProperty(exports, &quot;__esModule&quot;, &#123; value: true &#125;);</span><br><span class="line">    var AppComponent = (function () &#123;</span><br><span class="line">        function AppComponent() &#123;</span><br><span class="line">            this.name = &apos;Angular&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return AppComponent;</span><br><span class="line">    &#125;());</span><br><span class="line">    AppComponent = __decorate([</span><br><span class="line">        core_1.Component(&#123; // (1)</span><br><span class="line">            selector: &apos;my-app&apos;,</span><br><span class="line">            template: &quot;&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;&quot;,</span><br><span class="line">        &#125;)</span><br><span class="line">    ], AppComponent);</span><br><span class="line">    exports.AppComponent = AppComponent;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过 Angular 2 Decorators - part 1 文章，我们知道 TypeScript 类装饰器的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">declare type ClassDecorator = &lt;TFunction extends Function&gt;(target: TFunction)</span><br><span class="line">  =&gt; TFunction | void;</span><br></pre></td></tr></table></figure>
<p>而转换后 ES5 代码中 __decorate 函数的方法签名是 function (decorators, target, key, desc) 。因此我们可以推断，core_1.Component 是一个函数，该函数调用后返回一个 ClassDecorator 。类似于 Angular 2 Decorators - part 1 文章中的 Greeter 装饰器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Greeter(greeting: string) &#123;</span><br><span class="line">  return function(target: Function) &#123;</span><br><span class="line">    target.prototype.greet = function(): void &#123;</span><br><span class="line">      console.log(greeting);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Greeter(&apos;您好&apos;)</span><br><span class="line">class Greeting &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    // 内部实现</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myGreeting = new Greeting();</span><br><span class="line">myGreeting.greet(); // console output: &apos;您好!&apos;;</span><br></pre></td></tr></table></figure>
<p>那我们来看一下 @angular/core 模块中导出的 Component 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Component decorator and metadata.</span><br><span class="line"> */</span><br><span class="line">export const Component: ComponentDecorator = &lt;ComponentDecorator&gt;makeDecorator(</span><br><span class="line">    &apos;Component&apos;, &#123;</span><br><span class="line">      selector: undefined, // 用于定义组件在HTML代码中匹配的标签</span><br><span class="line">      inputs: undefined, // 组件的输入属性</span><br><span class="line">      outputs: undefined, // 组件的输出属性</span><br><span class="line">      host: undefined, // 绑定宿主的属性、事件等</span><br><span class="line">      exportAs: undefined, // 导出指令，使得可以在模板中调用</span><br><span class="line">      moduleId: undefined, // 包含该组件模块的id，它被用于解析模板和样式的相对路径 </span><br><span class="line">      providers: undefined, // 设置组件及其子组件可以用的服务</span><br><span class="line">      viewProviders: undefined, // 设置组件及其子组件(不含ContentChildren)可以用的服务</span><br><span class="line">      changeDetection: ChangeDetectionStrategy.Default, // 指定组件使用的变化检测策略</span><br><span class="line">      queries: undefined, // 设置组件的查询条件</span><br><span class="line">      templateUrl: undefined, // 为组件指定一个外部模板的URL地址</span><br><span class="line">      template: undefined, // 为组件指定一个内联的模板</span><br><span class="line">      styleUrls: undefined, // 为组件指定一系列用于该组件的样式表文件</span><br><span class="line">      styles: undefined, // 为组件指定内联样式</span><br><span class="line">      animations: undefined, // 设置组件相关动画</span><br><span class="line">      encapsulation: undefined, // 设置组件视图包装选项</span><br><span class="line">      interpolation: undefined, // 设置默认的插值运算符，默认是&quot;&#123;&#123;&quot;和&quot;&#125;&#125;&quot;</span><br><span class="line">      entryComponents: undefined // 设置需要被提前编译的组件</span><br><span class="line">    &#125;,</span><br><span class="line">    Directive);</span><br></pre></td></tr></table></figure>
<p>让我们继续来看一下 makeDecorator 这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// @angular/core/src/util/decorators.ts</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * const Component: ComponentDecorator = &lt;ComponentDecorator&gt;makeDecorator(</span><br><span class="line"> *   &apos;Component&apos;, &#123;...&#125;, Directive);</span><br><span class="line"> */</span><br><span class="line">function makeDecorator(name, props, parentClass, chainFn) &#123; </span><br><span class="line">  		// name: &apos;Component&apos;, props: &#123;...&#125;, parentClass: Directive</span><br><span class="line">        if (chainFn === void 0) &#123; chainFn = null; &#125;</span><br><span class="line">  </span><br><span class="line">  		// 创建Metadata构造函数</span><br><span class="line">        var metaCtor = makeMetadataCtor([props]); </span><br><span class="line">  		// objOrType: &#123; selector: &apos;my-app&apos;, template: &quot;&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;&quot; &#125;</span><br><span class="line">        function DecoratorFactory(objOrType) &#123; </span><br><span class="line">          </span><br><span class="line">          	// 确保已经引入了Reflect库</span><br><span class="line">            if (!(Reflect &amp;&amp; Reflect.getMetadata)) &#123;</span><br><span class="line">                throw &apos;reflect-metadata shim is required when using class decorators&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">          	// 判断this对象是否为DecoratorFactory的实例，若是则合并metadata信息</span><br><span class="line">            if (this instanceof DecoratorFactory) &#123; </span><br><span class="line">                metaCtor.call(this, objOrType);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var annotationInstance = new DecoratorFactory(objOrType); </span><br><span class="line">            var chainAnnotation = typeof this === &apos;function&apos; &amp;&amp; </span><br><span class="line">                Array.isArray(this.annotations) ? this.annotations : [];</span><br><span class="line">            chainAnnotation.push(annotationInstance);</span><br><span class="line">          </span><br><span class="line">          	// 定义类装饰器，参数即要装饰的类</span><br><span class="line">            var TypeDecorator = function TypeDecorator(cls) &#123;</span><br><span class="line">                // 首先先获取装饰类关联的annotations信息，若不存在则创建</span><br><span class="line">                // 保存上面创建的annotationInstance实例，并调用保存更新后的annotations信息</span><br><span class="line">                var annotations = Reflect.getOwnMetadata(&apos;annotations&apos;, cls) || [];</span><br><span class="line">                annotations.push(annotationInstance); </span><br><span class="line">                Reflect.defineMetadata(&apos;annotations&apos;, annotations, cls);</span><br><span class="line">                return cls;</span><br><span class="line">            &#125;;</span><br><span class="line">          </span><br><span class="line">            TypeDecorator.annotations = chainAnnotation;</span><br><span class="line">            TypeDecorator.Class = Class;</span><br><span class="line">            if (chainFn) chainFn(TypeDecorator);</span><br><span class="line">          </span><br><span class="line">            return TypeDecorator;</span><br><span class="line">        &#125;</span><br><span class="line">        if (parentClass) &#123;</span><br><span class="line">            DecoratorFactory.prototype = Object.create(parentClass.prototype);</span><br><span class="line">        &#125;</span><br><span class="line">        DecoratorFactory.prototype.toString = function () &#123; return (&quot;@&quot; + name); &#125;;</span><br><span class="line">        DecoratorFactory.annotationCls = DecoratorFactory;</span><br><span class="line">        return DecoratorFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生成Metadata构造函数</span><br><span class="line">function makeMetadataCtor(props: ([string, any] | &#123;[key: string]: any&#125;)[]): any &#123;</span><br><span class="line">   // args: [&#123; selector: &apos;my-app&apos;, template: &quot;&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;&quot; &#125;]</span><br><span class="line">  return function ctor(...args: any[]) &#123;</span><br><span class="line">    props.forEach((prop, i) =&gt; &#123;</span><br><span class="line">       // argVal: &#123; selector: &apos;my-app&apos;, template: &quot;&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;&quot; &#125;</span><br><span class="line">      const argVal = args[i];</span><br><span class="line">      if (Array.isArray(prop)) &#123;</span><br><span class="line">        this[prop[0]] = argVal === undefined ? prop[1] : argVal;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // propName: &apos;selector&apos; | &apos;template&apos;</span><br><span class="line">        for (const propName in prop) &#123; </span><br><span class="line">          this[propName] =</span><br><span class="line">              argVal &amp;&amp; argVal.hasOwnProperty(propName) ? </span><br><span class="line">            	argVal[propName] : prop[propName];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过阅读以上的源码，我们发现当调用 makeDecorator(‘Component’, {..}, Directive) 方法时，返回的是</p>
<p>DecoratorFactory 函数，该函数只接收一个参数，当调用该工厂函数时，则返回 TypeDecorator 函数即类装饰器。回到最早的例子，当我们调用 core_1.Component({ selector: ‘my-app’, template: “…” }) 创建的 annotationInstance 实例，内部结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      selector: &apos;my-app&apos;, </span><br><span class="line">      inputs: undefined, </span><br><span class="line">      outputs: undefined, </span><br><span class="line">      host: undefined, </span><br><span class="line">      exportAs: undefined, </span><br><span class="line">      moduleId: undefined,  </span><br><span class="line">      providers: undefined, </span><br><span class="line">      viewProviders: undefined, </span><br><span class="line">      changeDetection: ChangeDetectionStrategy.Default, </span><br><span class="line">      queries: undefined, </span><br><span class="line">      templateUrl: undefined, </span><br><span class="line">      template: &quot;&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;&quot;,</span><br><span class="line">      styleUrls: undefined, </span><br><span class="line">      styles: undefined, </span><br><span class="line">      animations: undefined, </span><br><span class="line">      encapsulation: undefined, </span><br><span class="line">      interpolation: undefined, </span><br><span class="line">      entryComponents: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们来梳理一下整个流程，系统初始化的时候，会调用 makeDecorator(‘Component’, {..}, Directive) 方法，创建 ComponentDecorator 工厂 。我们编写的 <a href="https://github.com/component" target="_blank" rel="noopener">@component</a> 组件转换成 ES 5 代码后，会使用用户自定义的 metadata 信息作为参数，自动调用 ComponentDecorator 工厂函数，该函数内部实现的主要功能就是创建 annotationInstance 对象，最后返回 TypeDecorator 类装饰器。该类装饰器会被 __decorate([…], AppComponent) 函数调用，参数 traget 就是我们要装饰的类 。</p>
<p>我有话说</p>
<ol>
<li>因为一个类可以应用多个装饰器，所以 var annotations = Reflect.getOwnMetadata(‘annotations’, cls) || [] 语句中，annotations 的值是数组。在 Angular 2 中，应用多个装饰器的情形是使用 <a href="https://github.com/optional" target="_blank" rel="noopener">@optional</a> 、<a href="https://github.com/Inject" target="_blank" rel="noopener">@Inject</a>()、<a href="https://github.com/host" target="_blank" rel="noopener">@host</a> 等参数装饰器，描述构造函数中需要注入的依赖对象。</li>
<li>通过 Reflect.defineMetadata API 定义的 metadata 信息，是保存在 <code>window[&#39;__core-js_shared__&#39;]</code>对象的 metadata 属性中。感兴趣的话，大家可以直接在 Console 控制台，输入 <code>window[&#39;__core-js_shared__&#39;]</code> 查看该对象内部保存的信息。</li>
<li><a href="https://github.com/component" target="_blank" rel="noopener">@component</a> 中 @ 符号的作用是为了告诉 TypeScript 编译器，@ 后面的是装饰器函数或装饰器工厂，需要特殊处理。假设在 <a href="https://github.com/component" target="_blank" rel="noopener">@component</a>({…}) 中去掉 @ 符号，那么变成了普通的函数调用，这样马上就会报错，因为我们并没有定义 Component 函数。通过观察转换后的代码，我们发现 <a href="https://github.com/component" target="_blank" rel="noopener">@component</a>({…}) 被转换成 core_1.Component ，它就是从 @angular/core 导入的装饰器函数。</li>
</ol>
<p>总结</p>
<p>本文介绍了 Angular 2 中最常用的 ComponentDecorator 装饰器，并通过简单的例子，一步步分析该装饰器的内部工作流程。不过我们只介绍了 Angular 2 框架内部如何解析、创建及保存 metadata 信息，还未涉及到组件初始化的过程中，如何读取、应用组件对应的 metadata 信息。另外在后续的 Angular 2 DI 文章中，我们还会继续分析其它装饰器的工作原理。</p>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2020/04/06/angular2-decorator/" class="article-date">
  <time datetime="2020-04-05T18:20:58.000Z" itemprop="datePublished">2020-04-06</time>
</a>

        </li>
        
        
        <hr>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2020/04/25/angular-testing/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          angular-单元测试
        
      </div>
    </a>
  
  
    <a href="/2020/04/06/angular2-cli-1/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">angular2-cli</div>
    </a>
  
</nav>


  
</article>




      </div>
      
    <footer id="footer" class="post-footer footer">
      <hr>
      <div id="footerContent" class="footer-content">
        <p>闲步山雨后,静待晚林风 Post</p>


      </div>
    </footer>

      

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
